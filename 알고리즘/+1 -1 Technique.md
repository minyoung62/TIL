# 1+ -1 Technique

## 간단한 문제
  ```
  일직선 위에 n개의 구간이 주어졌을 때, 구간이 가장 많이 겹치는 부분에서 몇 개의 구간이 겹치는지를 구하라
  -조건-
  1 <= n <= 100,000
  1 <= x1, x2 <= 200,000
  ```
### 나이브한 풀이
  - 위 문제의 나이브한 풀이는 각 구간에서의 겹치는 부분을 모두 세고 이후 최댓값을 구하면 된다.
  - 이러면 n이 10만이 넘고 구간의 길이가 최대 200,000이기 때문에 빅오 표기법으로 O(n*x2)가 걸린다 

## 최적화
### 최적화 부분 생각하기
  - 나이브한 풀이 방법에서 모든 구간의 길이에 대해 겹치는 부분을 세는 것은 매우 비효율적으로 보인다.
  - 왜냐하면 특정 구간이 주어졌을 때 우리는 시작과 끝을 알기 때문이다.
  - 시작과 끝을 안다는 것은 그 사이에는 무조건 1개 이상의 겹치는 부분이 있다는 의미이고 때문에 시작과 끝이 중요한 포인트라고 볼 수 있다.
  - 그럼 시작과 끝에 어떤 작업을 해주면 될까? 
  - 만약 시작 부분부터 제일 끝까지 1씩 추가해준다면 모든 주어지는 구간에 대해 적용하게 되면 원하는 답이 나오지 않을 것이다 
  - 그 이유는 구간이 끊어졌을 때 값을 -1 해줘야 하기 때문이다. 
  - 이러한 상황을 보았을 때 특정 구간의 시작과 끝이 주어지고 시작에는 1 끝에는 -1을 해주면 된다. 
  - 이때 사용하는게 accumulate배열이다. accumulate 배열은 1과 -1을 누적시켜주는 배열이다 .
  - 이를 통해 실제 우리가 원하는 겹치는 구간이 몇개있는지 O(n)만에 구할 수 있다. 
### 소스코드 
  ```
  n = int(input())

  accumulate = [0] * 200002
  a = [0] * 200002

  for i in range(n):
      x1, x2 = map(int, input().split())
      accumulate[x1] += 1
      accumulate[x2] -= 1

  a[0] = accumulate[0]
  for i in range(1, len(accumulate)):
      a[i] = a[i -1] + acc[i]

  print(max(a))
  ```
