## 1 사람을 사랑한 기술
## 2 자바와 절차적/구조적 프로그래밍
  ### 다시보는 main() 메서드: 메서드 스택 프레임
  ``` java
    public class Start {
    public static void main(String[] args) {
      System.out.println("Hello OOP!!!");
    } 
  }
  ```
  - JRE가 프로그램 안에 main() 메서드가 있는지 확인
  - JRE는 Start 클래스에 main() 메소드 발견
  - main() 메소드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비 착수
  - 가상의 기계인 JVM에 전원을 넣어 부팅 
  - 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행
  - JVM이 맨 먼저 하는 일은 전처리 과정 
  - 모든 자바 프로그램은 반드시 java.lang 패키지를 포함해야함 때문에 JVM은 가장 먼저 java.lang 패키지를 스태틱 영역에 가져다 놓음 
  - 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 넣음 
  - main() 메서드를 스택영역에 적재
  - System.out.println("Hello OOP!!") 구문 실행
  - 화면에 출력 
  - main() 메서드 스택영역에서 소멸 
  - JRE는 JVM을 종료 JRE 자체도 운영체제 상의 메모리에서 사라짐 
  
  ### 멀티 스레드/ 멀티 프로세스의 이해
  - 멀티 스레드의 메모리에 스택 영역은 스레드 개수만큼 분할해서 사용(스태틱과 힙은 공유)
  - 멀티 프로세스는 다수의 데이터 저장 영역, 다수의 스태틱, 스택, 힙 영역을 가짐 
  - 자바 웹 프로그래밍에서 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성
    - 이유는 멀티 스레드는 스태틱과 힙을 공유하기 때문에 멀티 프로세스보다 비교적 가볍고 효율적!
  - 멀티 스레드의 문제점
    - 전역 변수의 문제점 존재 
  - 문제 코드 
  ``` java
  public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
      Start6 t1 = new Start6();
      Start6 t2 = new Start6();

      t1.start();
      t2.start();
    }

    public void run() {
      for (int count = 0; count < 10; count++) {
        System.out.println(share++);

        try {
          sleep(1000);
        } catch (InterruptedException e) {
        }
      }
    }
  }
  
  ```
## 자바와 객체 지향
  - 객체 지향의 4대 특성
    - 캡슐화(정보 은닉)
    - 상속(재사용)
    - 추상화(모델링)
      - 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합하는 것 = 모델링
      - 클래스 설계에서 추상화가 사용됨
      - 객체 지향에서 추상화의 결과는 클래스
      - 상속을 통한 추상화, 구체화
      - 인터페이스를 통한 추상화
      - 다형성을 통한 추상화
      - 자바는 class라는키워드를 통해 추상화 제공
      - 자바는 "클래스 객체_참조_변수 = new 클래스();"를 통해 클래스와 객체 관계를 표현     
    - 다형성(사용 편의)    

## 자바가 확장한 객체 지향
  ### 클래스 생성 시의 실행 블록, static 블록
  - 객체 생성자는 있지만 클래스 생성자는 존재하지 않음
  - 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록인 static 블록이 있음
  ``` java
  public class 동물 {
    static {
      System.out.println("동물 클래스 레디 온!");
    }
  }
  ```
  ``` java
  public class Driver01() {
    public static void main(String[] args) {
      동물 뽀로로 = new 동물(); 
    }
  }
  ```
  - 결과 : 동물 클래스 레디 온!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      동물 뽀로로 = new 동물(); 
    }
  } 
  ```
  - 결과 : main 메서드 시작!\n 동물 클래스 레디온 
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      System.out.println(Animal.age);
    }
  }

  class Animal {
    static int age = 0;
    static {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!\n Animal 클래스 ready on!\n 0
  - 정리
    - 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 메모리의 스태틱 영역에 로딩, 이때 단 한번 해당 클래스의 static 블록이 실행
  - 클래스가 제일 처음 사용되는 경우는 아래 3가지 경우가 있음
    - 클래스의 정적 속성을 사용할 때
    - 클래스의 정적 메서드를 사용할 때
    - 클래스의 인스턴스를 사용할 때
  ### final 키워드
  - final은 마지막, 최종의 의미 클래스, 변수, 메서드에 사용
  - final과 클래스
    ``` java
    public final class 고양이 {}
    ```
    - 상속을 허락하지 않겠다는 의미
  - final과 변수
    ``` java
    public class 고양이{
      final static int 정적상수1 = 1;
      final static int 정적상수2;
      
      final int 객체상수1 = 1;
      final int 객체상수2 = 2;
      
      static {
        정적상수2 = 2;
        
        // 상수는 한 번 초기화되면 값을 변경할 수 없다
        // 정적상수2 = 4;
      }
      
      고양이() {
        객체상수2 = 2;
        
        //상수는 한 번 초기화되면 값을 변경할 수 없다
        //객체상수2 = 4;
        
        final int 지역상수1 = 1;
        final int 지역상수2;
        
        지역상수2 = 2;
      }
    }
    ```
    - 정적 생성자에 해당하는 static 블록 내부에서 초기화 가능 
    - 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화 가능
  - final과 메서드
    - 오버라이딩 금지
### instanceof 연산자
  - 인스턴스는 클래스를 통해 만들어진 객체
  - instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자 
  - instanceof 연산자는 결과로 true 또는 false를 반납 
  - 사용법
    - 객체_참조_변수 instanceof 클래스명
  ``` java
  class 동물 {
    
  }
  class 조류 extends 동물{
  
  }
  class 펭귄 extends 조류{
  
  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      조류 조류객체 = new 조류();
      펭귄 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  class 동물 {

  }

  class 조류 extends 동물 {

  }

  class 펭귄 extends 조류 {

  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      동물 조류객체 = new 조류();
      동물 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  interface 날수있는 {

  }

  class 박쥐 implements 날수있는 {

  }

  class 참새 implements 날수있는 {

  }

  public class Driver {
    public static void main(String[] args) {
      날수있는 박쥐객체 = new 박쥐();
      날수있는 참새객체 = new 참새();

      System.out.println(박쥐객체 instanceof 날수있는);
      System.out.println(박쥐객체 instanceof 박쥐);

      System.out.println(참새객체 instanceof 날수있는);
      System.out.println(참새객체 instanceof 참새);
    }
  }
  ```
  - 결과 : 모두 true
## 객체 지향 설계 5원칙 - SOLID
  ### SRP(단일 책임 원칙)
  - ![image](https://user-images.githubusercontent.com/61530368/176111724-925103cb-4dcd-4805-945e-bad94d0bddca.png)
    - 남자 클래스에 많은 역할(책임) 존재 
  - ![image](https://user-images.githubusercontent.com/61530368/176111981-2dc5d090-025e-464c-9af4-6d99a29f04ef.png)
    - 남자 클래스에 단일 책임 원칙을 적용해 여러 개의 클래스로 분리 
  - ``` java
    public class 강아지 {
    final static Boolean 숫컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;

    void 소변보다() {
        if (this.성별 == 숫컷) {
          // 한쪽 다리를 들고 소변을 본다.
        } else {
          // 뒤다리 두 개로 앉은 자세로 소변을 본다.
        }
      }
    }
    ```
    - 강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임(행위)원칙을 위배 (대표적인 냄새가 바로 분기 처리를 위한 if문)
  - 리팩토링
  ``` java
  public abstract class 강아지 {
    abstract void 소변보다();
  }
  
  public class 숫컷강아지 extends 강아지 {
    void 소변보다() {
      // 한쪽 다리를 들고 소변을 본다.
    }
  }
  
  public class 암컷강아지 extends 강아지 {
    void 소변보다() {
      // 뒤다리 두 개로 앉은 자세로 소변을 본다.
    }
  }
  ```
  - 단일 책임의 원리는 모델링 과정을 담당하는 추상화와 결부되어있다
### OCP(개방 폐쇄 원칙)
  - 소프트웨어 엔티티(클래스, 모듈, 함수)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야한다 
  - JDBC의 개방 폐쇠 원칙
    - ![image](https://user-images.githubusercontent.com/61530368/176116129-dda01569-7771-4522-bc8f-5cef3112ce38.png)
    - 클라이언트는 데이터베이스가 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없음
  - 자바에서 개방 폐쇄 원칙
    - 자가 개발자가 소스코드를 작성 
    - 실행시 여러가지 운영체제에서 실행될 수 있음 
    - 각 운영체제별 JVM과 목전파일(.class)이 있기에 개발자는 다양한 구동 환경에 대해 걱정하지 않고 실행 가능
### LSP(리스코프 치환 원칙)
  - 서브타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다
    - = 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다 
  - ![image](https://user-images.githubusercontent.com/61530368/176117525-7e27034d-e087-470c-9ef6-e5d18d8b7232.png)
    - 리스코프 치환 원칙 위반 사례 - 계층도/조직도
  - ![image](https://user-images.githubusercontent.com/61530368/176117641-0ce2194a-e1a2-478f-a231-744e68d0dbd6.png)
    - 리스코프 치환 원칙 적용 사례 - 분류도
### ISP(인터페이스 분리 원칙)
  - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
  - ![image](https://user-images.githubusercontent.com/61530368/176119977-13cf2e8a-6b65-4c29-8496-d25f2554d8b3.png)
    - 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스로 제한
    - 어머니와 있을 때는 아들 인터페이스로 제한
    - 직장 상사 앞에서는 사원 인터페이스로 제한
    - 소대장 앞에서는 소대원 인터페이스로 제한 
    - 이것이 바로 인터페이스 분할 원칙의 핵심
  - 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책
  - 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책
    - 인터페이스 최소주의 원칙으로 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공
    - 상위 클래스는 풍부할수록 좋고, 인터페이스는 작을수록 좋다 
  - "상위 클래스는 풍부할수록 좋고, 인터페이스는 작을수록 좋다"의 이유
    - ![image](https://user-images.githubusercontent.com/61530368/176121250-a48cfeb7-d4c9-47d8-a658-7ed1bf92566a.png)
    - 빈약한 상위 클래스
    ``` java
    public class Driver {
      public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
            "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
            "19-12345678");

        System.out.println(김학생.이름);
        System.out.println(이군인.이름);

        // System.out.println(김학생.생일); // 사용불가
        // System.out.println(이군인.생일); // 사용불가

        System.out.println(((학생) 김학생).생일); // 캐스팅 필요
        System.out.println(((군인) 이군인).생일); // 캐스팅 필요

        // System.out.println(김학생.주민등록번호); // 사용불가
        // System.out.println(이군인.주민등록번호); // 사용불가

        System.out.println(((학생) 김학생).주민등록번호);
        // 캐스팅 필요
        System.out.println(((군인) 이군인).주민등록번호);
        // 캐스팅 필요

        김학생.먹다();
        이군인.먹다();

        // 김학생.자다(); // 사용불가
        // 이군인.자다(); // 사용불가

        ((학생) 김학생).자다(); // 캐스팅 필요
        ((군인) 이군인).자다(); // 캐스팅 필요

        // 김학생.소개하다(); // 사용불가
        // 이군인.소개하다(); // 사용불가

        ((학생) 김학생).소개하다(); // 캐스팅 필요
        ((군인) 이군인).소개하다(); // 캐스팅 필요

        ((학생) 김학생).공부하다(); // 캐스팅 필요
        ((군인) 이군인).훈련하다(); // 캐스팅 필요
      }
    }
    ```
      - 상속의 혜택을 제대로 누리지 못함 
    - 풍부한 상위 클래스
    ``` java
    public class Driver {
      public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
            "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
            "19-12345678");

        System.out.println(김학생.이름);
        System.out.println(이군인.이름);

        System.out.println(김학생.생일);
        System.out.println(이군인.생일);

        System.out.println(김학생.주민등록번호);
        System.out.println(이군인.주민등록번호);

        // System.out.println(김학생.학번); // 사용불가
        // System.out.println(이군인.군번); // 사용불가

        System.out.println(((학생) 김학생).학번);
        // 캐스팅 필요
        System.out.println(((군인) 이군인).군번);
        // 캐스팅 필요

        김학생.먹다();
        이군인.먹다();

        김학생.자다();
        이군인.자다();

        김학생.소개하다();
        이군인.소개하다();

        // 김학생.공부하다(); // 사용불가
        // 이군인.훈련하다(); // 사용불가

        ((학생) 김학생).공부하다(); // 캐스팅 필요
        ((군인) 이군인).훈련하다(); // 캐스팅 필요
      }
    }
    ```
### DIP(의존 역전 원칙)
  - 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야한다. 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야한다. 자주 변경되는 구체 클래스에 의존하지 마라!
  - ![image](https://user-images.githubusercontent.com/61530368/176124014-14fc880d-b29d-4d86-8d24-a98d201c6662.png)
    - 자동차는 한 번 사면 몇 년은 타야 하는데 스노우타이어는 계쩔이 바뀌면 일반 타이어로 교채해야함
  - ![image](https://user-images.githubusercontent.com/61530368/176124267-29fb1a5f-afa2-4815-ace2-43d655dae195.png)
    - 자동차가 구체체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에 의존하게 함
    - 이는 개방 폐쇄 원칙(OCP)와 유사
    - 이렇게 하나의 해결책을 찾으면 그 안에 여러 설계 원칙이 녹아있는 경우가 많음
    - 즉, 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지지 않게 하는 것이 의존 역전 원칙
### 객체 지향 세계와 SOLID 정리 
  - SRP(단일 책임 원칙) : 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다
  - OCP(개방 폐쇄 원칙) : 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다
  - LSP(리스코프 치환 원칙) : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다
  - ISP(인터페이스 분리 원칙) : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
  - DIP(의존 역전 원칙) : 자신보다 변하기 쉬운 것에 의존하지마라 

## 스프링이 사랑한 디자인 패턴
### 어댑터 패턴(Adapter Pattern)
  - 어댑터 패턴이란?
    - 서로 다른 두 인터페이스 사이에 통신이 가능하게 해주는 것
  - 예시
    - JDBC
    - 플랫폼별 JRE
  - 어댑터 미적용
    ``` java
    public class ServiceA {
      void runServiceA() {
        System.out.println("ServiceA");
      }
    }
    
    public class ServiceB {
      void runServiceB() {
        System.out.println("ServiceB");
      }
    }

    public class ClientWithNoAdapter {
      public static void main(String[] args) {
        ServiceA sa1 = new ServiceA();
        ServiceB sb1 = new ServiceB();

        sa1.runServiceA();
        sb1.runServiceB();
      }
    }
    ```
    - ![image](https://user-images.githubusercontent.com/61530368/176205816-ddbcc635-8a5d-4d9e-a8c4-b41c23c40dd7.png)
    - sa1 참조 변수와 sb1 참조 변수를 통해호출하는 각 메서드가 비슷한 일을 하지만 메서드명이 다름
  - 어댑터 적용
    ``` java
        public class AdapterServicA {
      ServiceA sa1 = new ServiceA();

      void runService() {
        sa1.runServiceA();
      }
    }
    
    public class AdapterServicB {
      ServiceB sb1 = new ServiceB();

      void runService() {
        sb1.runServiceB();
      }
    }
    
    public class ClientWithAdapter {
      public static void main(String[] args) {
        AdapterServicA asa1 = new AdapterServicA();
        AdapterServicB asb1 = new AdapterServicB();

        asa1.runService();
        asb1.runService();
      }
    }
    ```
    - ![image](https://user-images.githubusercontent.com/61530368/176206628-c74e5859-3e00-4ca7-a07a-68a9f5fed282.png)
    - 클라이언트(ClientWithAdapter)가 변환기를 통해 service()라는 동일한 메서드명으로 두 객체의 메서드를 호출
    - 어댑터 패턴은 합성, 즉 객체를 속성으로 만들어서 참조하는 디자인 패턴
    - 호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴
### 프록시 패턴(Prox Pattern)
  - 프록시란?
    - 대리자, 대변인이라는 의미를 가진다  
    - 제어의 흐름을 변경하거나 별도의 로직 처리를 목적
    - 클라이언트가 받는 반환값을 특별한 경우가 아니면 변경하지 않는다
  - No 프록시
    - ![image](https://user-images.githubusercontent.com/61530368/176207480-9eda9163-334a-4e8b-bc80-80e778178db7.png)
    - ![image](https://user-images.githubusercontent.com/61530368/176207557-c96f0dcc-2d0c-4e65-ba82-98871ac9d0c4.png) 
    - ClientWithNoProxy가 Service 객체의 runSomething() 메서드를 직접 호출
    ```java
    public class Service {
      public String runSomething() {
        return "서비스 짱!!!";
      }
    }
    
    public class ClientWithNoProxy {
      public static void main(String[] args) {
        // 프록시를 이용하지 않은 호출
        Service service = new Service();
        System.out.println(service.runSomething());
      }
    }
    ```
  - 프록시 
    - ![image](https://user-images.githubusercontent.com/61530368/176209370-7398c976-1428-4c75-a514-170436bd27c0.png) 
    - ![image](https://user-images.githubusercontent.com/61530368/176209319-c29191ba-7bde-40a4-bc9c-abf0a042cd37.png)
    - 실제 서비스 객체가 가진메서드와 같은 이름의 메서드를 사용하는데, 이를 위해 인터페이스 사용
    - 인터페이스를 사용하면 서비스 객체가 들어갈 자리에 대리자 객체를 투입해 클라이언트 쪽에서는 실제 서비스 객체를 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리 가능
    ``` java
    public interface IService {
      String runSomething();
    }
    
    public class Service implements IService {
      public String runSomething() {
        return "서비스 짱!!!";
      }
    }
    
    public class Proxy implements IService {
      IService service1;

      public String runSomething() {
        System.out.println("호출에 대한 흐름 제어가 주목적, 반환 결과를 그대로 전달");

        service1 = new Service();
        return service1.runSomething();
      }
    }
    
    public class ClientWithProxy {
      public static void main(String[] args) {
        // 프록시를 이용한 호출
        IService proxy = new Proxy();
        System.out.println(proxy.runSomething());
      }
    }
    ```
    - 프록시 패턴의 중요 포인트
      - 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스 사용
      - 대리자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
      - 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다
      - 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다

   
### 데코레이터 패턴(Decorator Pattern)
  - 데코레이터 패턴이란?
    - 도장/도배업자를 의미(원본에 장식을 더하는 패턴)
    - 클라이언트가 받는 반환값에 장식을 더한다 
    ``` java
    public interface IService {
      String runSomething();
    }
    
    public class Service implements IService {
      public String runSomething() {
        return "서비스 짱!!!";
      }
    }
    
    public class Decoreator implements IService {
      IService service;

      public String runSomething() {
        System.out.println("호출에 대한 장식 주목적, 클라이언트에게 반환 결과에 장식을 더하여 전달");

        service = new Service();
        return "정말" + service.runSomething();
      }
    }
    
    public class ClientWithDecolator  {
      public static void main(String[] args) {
        IService decoreator = new Decoreator();
        System.out.println(decoreator.runSomething());
      }
    }
    ```
    - 데코레이터 패턴의 중요 포인트
      - 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스 사용
      - 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성)
      - 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려줌
      - 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직 수행 가능
### 싱글턴 패턴(SingLeton Pattern)
  - 싱글턴 패턴이란?
    - 인스턴스를 하나만 만들어 사용하기 위한 패턴
    - 커넥션 풀, 스레드 풀, 디바이스 설정 객체 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게되고, 또 프로그램이 예상치 못한 결과를 초래할 수 있음
  - 구현에 필요한 요소
    - new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정
    - 유일한 단일 객체를 반환할 수 있는 정적 메서드 필요
    - 유일한 단일 객체를 참조할 정적 참조 변수 필요
  ``` java
  public class Singleton {
    static Singleton singletonObject; // 정적 참조 변수

    private Singleton() {
    }; // private 생성자

    // 객체 반환 정적 메서드
    public static Singleton getInstance() {
      if (singletonObject == null) {
        singletonObject = new Singleton();
      }

      return singletonObject;
    }
  }
  
  public class Client {
    public static void main(String[] args) {
      // private 생성자임으로 new 할 수 없다.
      // Singleton s = new Singleton();

      Singleton s1 = Singleton.getInstance();
      Singleton s2 = Singleton.getInstance();
      Singleton s3 = Singleton.getInstance();

      System.out.println(s1);
      System.out.println(s2);
      System.out.println(s3);

      s1 = null;
      s2 = null;
      s3 = null;
    }
  }
  ```
  - ![image](https://user-images.githubusercontent.com/61530368/176353136-6606df06-ee2d-40f2-95cc-625e689829d8.png)
    - 4개의 참조 변수(singltonObject, s1, s2, s3)가 하나의 단일 객체를 참조
    - 단일 객체인 경우 공유 객체로 사용되기 때문에 속성을 갖지 않게하는 것이 정석
    - 단일 객체가 속성을 갖게 되면 하나의 참조 변수가 변경한 단일 객체의 속성이 다른 참조변수에 영향을 끼치기 때문
    - 추가로 단일 객체가 다른 단일 객체에 대한 참조를 속성으로 가지는 것은 문제가 되지 않음
  - 실글턴 패턴의 특징
    - private 생성자를 갖는다
    - 단일 객체 참조 변수를 정적 속성을 갖는다
    - 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다
    - 단일 객체는 쓰기 가능한 속성을 갖지 안흔ㄴ 것이 정석
### 템플릿 메서드 패턴(Template Method Pattern)
  - no 템플릿 메서드 패턴
    ``` java
    public class Dog {
      public void playWithOwner() {
        System.out.println("귀염둥이 이리온...");
        System.out.println("야옹~ 야옹~");
        System.out.println("꼬리 살랑 살랑~");
        System.out.println("잘했어");
      }
    }

    public class Cat {
      public void playWithOwner() {
        System.out.println("귀염둥이 이리온...");
        System.out.println("야옹~ 야옹~");
        System.out.println("꼬리 살랑 살랑~");
        System.out.println("잘했어");
      }
    }

    ```
    - 2번째 출력 빼고 모두 같은 것을 볼 수 있다
  - 템플릿 메서드 패턴 사용
    ``` java
    public abstract class Animal {
      // 템플릿 메서드
      public void playWithOwner() {
        System.out.println("귀염둥이 이리온...");
        play();
        runSomething();
        System.out.println("잘했어");
      }

      // 추상 메서드
      abstract void play();

      // Hook(갈고리) 메서드
      void runSomething() {
        System.out.println("꼬리 살랑 살랑~");
      }
    }
    
    public class Dog extends Animal {
      @Override
      // 추상 메서드 오버라이딩
      void play() {
        System.out.println("멍! 멍!");
      }

      @Override
      // Hook(갈고리) 메서드 오버라이딩
      void runSomething() {
        System.out.println("멍! 멍!~ 꼬리 살랑 살랑~");
      }
    }
    
    public class Cat extends Animal {
      @Override
      // 추상 메서드 오버라이딩
      void play() {
        System.out.println("야옹~ 야옹~");
      }

      @Override
      // Hook(갈고리) 메서드 오버라이딩
      void runSomething() {
        System.out.println("야옹~ 야옹~ 꼬리 살랑 살랑~");
      }
    }
    
    public class Driver {
      public static void main(String[] args) {
        Animal bolt = new Dog();
        Animal kitty = new Cat();

        bolt.playWithOwner();

        System.out.println();
        System.out.println();

        kitty.playWithOwner();
      }
    }
    ```
    - ![image](https://user-images.githubusercontent.com/61530368/176354447-e943f300-e067-44c1-9cde-0d9f6e383f08.png)
      - aNIMAL에는 템플릿(견본)을 제공하는 PLAYwITHoWNER() 메서드와 하위 클래스에게 구현을 강제하는 play() 추상 메서드, 하위 클래스가 선택적으로 오버라이딩할 수 있는 runSomething() 메서드가 있다
      - 하위 클래스인 Dog과 Cat은 상위 클래스인 Animal에서 구현을 강제하고 있는 play() 추상 메서드를 반드시 구현해야 한다
      - runSomething() 메서드는 선택적으로 오버라이딩할 수 있다
      - 상위 클래스에 공통 로직을 수행하는 템플릿 메서드와 하위 클래스에 오버라이딩을 강제하는 추상 메서드 또는 선택적으로 오버라이딩할 수 있는 훅(Hook) 메서드를 두는 패턴을 템플릿 메서드 패턴이라고 한다
    - 템플릿 메서드 패턴이 의존 역전 원칙(DIP)을 활용
### 팩터리 메서드 패턴(Factory Method Pattern)
  - 팩터리 메서드 패턴이란?
    - 팩터리는 공장을 의미
    - 공장은 물건을 생산하는데 객체 지향에서 팩터리는 객체를 생성
    - 팩터리 메서드는 객체를 생성 반환하는 메서드
    - 여기서 패턴이 붙으면 하위 클래스에서 팩터리 메서드를 오버라이딩해서 객체를 반환하게 하는 것을 의미 
  ``` java
  public abstract class Animal {
    // 추상 팩터리 메서드
    abstract AnimalToy getToy();
  }
  
  // 팩터리 메서드가 생성할 객체의 상위 클래스
  public abstract class AnimalToy {
    abstract void identify();
  }
  
  public class Dog extends Animal {
    // 추상 팩터리 메서드 오버라이딩
    @Override
    AnimalToy getToy() {
      return new DogToy();
    }
  }
  
  //팩터리 메서드가 생성할 객체
  public class DogToy extends AnimalToy {
    public void identify() {
      System.out.println("나는 테니스공! 강아지의 친구!");
    }
  }
  
  public class Cat extends Animal {
    // 추상 팩터리 메서드 오버라이딩
    @Override
    AnimalToy getToy() {
      return new CatToy();
    }
  }
  
    //팩터리 메서드가 생성할 객체
  public class CatToy extends AnimalToy {
    @Override
    public void identify() {
      System.out.println("나는 캣타워! 고양이의 친구!");
    }
  }
  
  public class Driver {
    public static void main(String[] args) {
      // 팩터리 메서드를 보유한 객체들 생성
      Animal bolt = new Dog();
      Animal kitty = new Cat();

      // 팩터리 메서드가 반환하는 객체들
      AnimalToy boltBall = bolt.getToy();
      AnimalToy kittyTower = kitty.getToy();

      // 팩터리 메서드가 반환한 객체들을 사용
      boltBall.identify();
      kittyTower.identify();
    }
  }
  ```
  - ![image](https://user-images.githubusercontent.com/61530368/176355792-7aadd5f4-b8c6-4322-aad8-9a857cfbfd32.png)
  - 오버라이드된 메서드가 객체를 반환하는 패턴
  - 팩터리 메서드 패턴이 의존 역전 원칙(DIP)을 활용
### 전략 패턴(Strategy Pattern)
  - 전략 패턴을 구성하는 요소
    - 전략 메서드를 가진 전략 객체
    - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
    - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자) 
  - 전략 패턴의 개념도
    - ![image](https://user-images.githubusercontent.com/61530368/176356609-7ad1747f-0ad1-4557-b7bf-60ff9106f974.png)
    - 클라이언트는 다양한 전략 중 하나 선택해 생성한 후 컨텍스트에 주입
  - 예시
    ``` java
    public interface Strategy {
      public abstract void runStrategy();
    }
    
    public class StrategyGun implements Strategy {
      @Override
      public void runStrategy() {
        System.out.println("탕, 타당, 타다당");
      }
    }
    
    public class StrategySword implements Strategy {
      @Override
      public void runStrategy() {
        System.out.println("챙.. 채쟁챙 챙챙");
      }
    }
    
    public class StrategyBow implements Strategy {
      @Override
      public void runStrategy() {
        System.out.println("슝.. 쐐액.. 쇅, 최종 병기");
      }
    }
    
    public class Soldier {
      void runContext(Strategy strategy) {
        System.out.println("전투 시작");
        strategy.runStrategy();
        System.out.println("전투 종료");
      }
    }
    
    public class Client {
      public static void main(String[] args) {
        Strategy strategy = null;
        Soldier rambo = new Soldier();

        // 총을 람보에게 전달해서 전투를 수행하게 한다.
        strategy = new StrategyGun();
        rambo.runContext(strategy);

        System.out.println();

        // 검을 람보에게 전달해서 전투를 수행하게 한다.
        strategy = new StrategySword();
        rambo.runContext(strategy);

        System.out.println();

        // 활을 람보에게 전달해서 전투를 수행하게 한다.
        strategy = new StrategyBow();
        rambo.runContext(strategy);
      }
    }
    ```
    - ![image](https://user-images.githubusercontent.com/61530368/176357018-9c0215d4-e798-4842-9eff-6e487958920f.png)
  - 전략 패턴은 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴
  - 전략 패턴에는 개방 폐쇄 원칙(OCP)과 의존 역전 원칙(DIP)이 적용됨
  
### 템플릿 콜백 패턴(Template Callback Pattern - 견본/회신 패턴)
  - 템플릿 콜백 패턴은 전략 패턴과 모든 것이 동일하지만 전략을 익명 내부 클래스로 정의해 사용한다는 특징이 있음 
  - 때문에 StrategyGun.java, StrategySword.java, StrategyBow.java가 필요 없음
  ``` java
  public interface Strategy {
    public abstract void runStrategy();
  }
  
  public class Soldier {
    void runContext(String weaponSound) {
      System.out.println("전투 시작");
      executeWeapon(weaponSound).runStrategy();
      System.out.println("전투 종료");
    }

    private Strategy executeWeapon(final String weaponSound) {
      return new Strategy() {
        @Override
        public void runStrategy() {
          System.out.println(weaponSound);
        }
      };
    }
  }
  
  public class Client {
    public static void main(String[] args) {
      Soldier rambo = new Soldier();

      rambo.runContext("총! 총초종총 총! 총!");

      System.out.println();

      rambo.runContext("칼! 카가갈 칼! 칼!");

      System.out.println();

      rambo.runContext("도끼! 독독..도도독 독끼!");
    }
  }
  ```
  - 템플릿 콜백 패턴은 전략 패턴의 일종이므로 개방 폐쇄 원칙(OCP)과 의존 역전 원칙(DIP)이 적용
  
## 스프링 삼각형과 설정 정보
### IoC/DI -제어의 역전/의존성 주입
  - 프로그래밍에서 의존성이란?
    - 의사 코드
      - 운전자가 자동차를 생산한다
      - 자동차는 내부적으로 타이어를 생산한다
    - 자바로 표현
      - new Car();
      - Car 객체 생성자에서 new Tire();
    - 의존성은 new다. new를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존한다
    - 전체가 부분에 의존한다 
    - 의존하는 객체(전체)와 의존된느 객체(부분) 사이에 집합 관계(Aggregation)와 구성 관계(Composition)로 구분할 수 있음 
  - 스프링을 적용하지 않은 자바 코드 
    - expert01 
      - ![image](https://user-images.githubusercontent.com/61530368/176589305-da93f83f-9839-435f-9b12-b2f88cd7ec96.png)
      ``` java
      interface Tire {
        String getBrand();
      }
      
      public class KoreaTire implements Tire {
        public String getBrand() {
          return "코리아 타이어";
        }
      }
      
      public class AmericaTire implements Tire {
        public String getBrand() {
          return "미국 타이어";
        }
      }
      
      public class Car {
        Tire tire;

        public Car() {
          tire = new KoreaTire();
          // tire = new AmericaTire();
        }

        public String getTireBrand() {
          return "장착된 타이어: " + tire.getBrand();
        }
      }
      
      public class Driver {
        public static void main(String[] args) {
          Car car = new Car();

          System.out.println(car.getTireBrand());
        }
      }
      ```
      - 자동차가 타이어를 생산(new)하는 부분에서 의존 관계가 일어남
  - 스프링 없이 의존성 주입하기1 - 생성자를 통한 의존성 주입
    - 의사코드
      - 운전가 타이어를 생성
      - 운전자가 자동차를 생산하면서 타이어를 장착
    - 자바로 표현 - 생성자 인자 이용
      - Tire tire = new KoreaTire();
      - Car car = new Car(tire);
    - 주입이란?
      - 주입이란말은 외부에서라는 뜻을 내포하고 있는 단어
      - 결국 자동차 내부에서 타이어를 생산하는 것이 아니라 외부에서 생산된 타이어를 자동차에 정착하는 작업이 주입임
    - ![image](https://user-images.githubusercontent.com/61530368/176590108-07d7dc32-cfab-4879-be9f-9152adfa7911.png)
      - Car의 생성자에 인자가 생김
    ``` java
          interface Tire {
        String getBrand();
      }

      public class KoreaTire implements Tire {
        public String getBrand() {
          return "코리아 타이어";
        }
      }

      public class AmericaTire implements Tire {
        public String getBrand() {
          return "미국 타이어";
        }
      }

      public class Car {
        Tire tire;

        public Car(Tire tire) {
          this.tire = tire;
        }

        public String getTireBrand() {
          return "장착된 타이어: " + tire.getBrand();
        }
      }

      public class Driver {
        public static void main(String[] args) {
          Tire tire = new KoreaTire();
          //Tire tire = new AmericaTire();

          Car car = new Car(tire);

          System.out.println(car.getTireBrand());
        }
      }
    ```
    - 이렇게 하면 확장성이 좋음
    - ChinaTire등이 새로 만들어졌을 때 Car 클래스를 수정할 필요 없음(또한 다시 컴파일할 필요도 없음)
    - 새로운 모듈(ChainaTire)가 만들어진다면 Driver와 ChainaTire만 재컴파일 및 재배포하면 됨 
  - 스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입
    - 의사 코드
      - 운전자가 타이어를 생산
      - 운전자가 자동차를 생산
      - 운전자가 자동차에 타이어를 장착
    - 자바로 표현 - 속성 접근자 메서드 사용
      - Tire tire = new KoreaTire();
      - Car car = new Car();
      - car.setTire(tire);
    - ![image](https://user-images.githubusercontent.com/61530368/176591121-64ad9e40-ae29-49d3-93c2-d28c7f107b46.png)
      - Car 클래스에서 생성자가 사라지고 get/set 속성 메서드가 생김
    ``` java
              interface Tire {
        String getBrand();
      }

      public class KoreaTire implements Tire {
        public String getBrand() {
          return "코리아 타이어";
        }
      }

      public class AmericaTire implements Tire {
        public String getBrand() {
          return "미국 타이어";
        }
      }

      public class Car {
        Tire tire;

        public Tire getTire() {
          return tire;
        }
        
        public Tire setTire() {
          this.tire = tire;
        }

        public String getTireBrand() {
          return "장착된 타이어: " + tire.getBrand();
        }
      }

      public class Driver {
        public static void main(String[] args) {
          Tire tire = new KoreaTire();
        
          Car car = new Car();
          car.setTire(tire)
          System.out.println(car.getTireBrand());
        }
      }
    ```
  - 스프링을 통한 의존성 주입 - XML 파일 사용
    - 의사 코드
      - 운전자가 종합 쇼핑몰에서 타이어를 구매
      - 운전자가 종합 쇼핑물에서 자동차를 구매
      - 운전자가 자동차에 타이어를 장착
    - 자바로 표현 - 속성 메서드 사용
      - AppplicationContext context = new ClassPathXmlApplicationContext("expert002.xml", Driver.class);
      - Tire tire = (Tire)context.getBean("tire");
      - Car car = (Car)context.getBean("car");
      - car.setTire(tire); 
    ``` java
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.support.ClassPathXmlApplicationContext;
    import org.springframework.context.support.FileSystemXmlApplicationContext;

    public class Driver {
      public static void main(String[] args) {
        //ApplicationContext context = new FileSystemXmlApplicationContext("src/main/java/expert002/expert002.xml");
        //ApplicationContext context = new ClassPathXmlApplicationContext("expert002.xml", Driver.class);
        ApplicationContext context = new ClassPathXmlApplicationContext("expert002/expert002.xml");

        // Car car = (Car)context.getBean("car");
        Car car = context.getBean("car", Car.class);

        // Tire tire = (Tire)context.getBean("tire");
        Tire tire = context.getBean("tire", Tire.class);

        car.setTire(tire);

        System.out.println(car.getTireBrand());
      }
    }
    ```
    ``` XML
    <beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd">

      <bean id="tire" class="expert002.KoreaTire"></bean>

      <bean id="americaTire" class="expert002.AmericaTire"></bean>

      <bean id="car" class="expert002.Car"></bean>

    </beans>
    ```
    - 입점된 상품에 대한 정보를 xml에 작성
    - 상품을 등록할 때는 bean 태그를 이용하여 등록
    - 각 상품을 구분하기 위한 id 속성과 그 상품을 어떤 클래스를 통해 생산(인스턴스화)해야 할지 나타내는 class 속성을 함께 지정
  - ![image](https://user-images.githubusercontent.com/61530368/176592595-70c3e0f9-2ad3-4728-96cc-6df75232b0d0.png)
    - KoreaTire.java가 XML 파일에서 id=tire인 bean 태그와 연결돼 있고, 다시 Driver.jva의 main() 메서드 안의 코드인 context.getBean("tire", Tire.class)와 연결되어 있음
  - 스프링을 도입해서 얻은 이득
    - 가장 큰 이득은 자동차의 타이어 브랜드를 변경할 때 그 무엇도 재컴파일/재배포하지 않아도 XML 파일만 수정하면 프로그램의 실행 결과를 바꿀 수 있음 
    - Driver.java의 Tire tire = context.getBean("tire", Tire.clasS); 부분이 타이어를 구매하는 부분인데, 자바 코드 어디에서도 KoreaTire클래스나 AmericaTire 클래스를 지칭하는 부분이 없음 (expert002.xml에 있기때문)
    - 때문에 AmericaTire로 타이어를 바꿔야 하더라도 자바 코드를 변경/재컴파일/재배포할 필요없이 xml에 bean태그 내용만 변경하고 웹 컨테이너를 재구동하면 바로 변경사항이 적용됨
- 스프링을 통한 의존성 주입 - 스프링 설정 파일(XML)에서 속성 주입
  - 의사 코드 - 점점 더 현실과 비슷해짐
    - 운전자가 종합 쇼핑물에서 자동차를 구매 요청
    - 종합 쇼핑몰은 자동차를 생산
    - 종합 쇼핑몰은 타이어를 생산
    - 종합 쇼핑몰은 자동차에 타이어를 장착
    - 종합 쇼핑몰은 운전자에게 자동차를 전달
  - 자바로 표현 
    ``` java
    ApplicationContext context = new ClassPathXmlApplicationContext("expert003/expert003.xml");
    Car car = context.getBean("car", Car.class)
    ```
  - XML로 표현
    ``` xml
    <bean id="koreaTire" class="expert003.KoreaTire"></bean>
    <bean id="americaTire" class="expert003.AmericaTire"></bean> 
    <bean id="car" class="expert003.Car">
      <property name="tire" ref="koreaTire"></property>
    </bean>
     ```
  - ![image](https://user-images.githubusercontent.com/61530368/176594700-81f1ac42-1c44-421d-ba17-ebcddd11d023.png)
    - 1번 선은 코드에서 Car를 구매하는 부분
    - Tire tire와 id가 koreaTire인 bean 태그를 잇는 2번 선은 타이어를 구매하는 부분
    - id="koreaTire"와 ref"koreaTire"를 잇는 내부의 3번선은 코리아 타이어를 자동차의 타이어 속성에 결합하는 부분
    - 2번 선과 3번 선에 연결된 글씨 부분은 XML 설정만으로 완성되므로 자바 코드에서 사라짐
    - 4번 태그 또한 자바 코드에서 
  - JUnit 테스트 케이스 
  ``` java
  import static org.junit.Assert.assertEquals;

  import org.junit.Test;
  import org.junit.runner.RunWith;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.test.context.ContextConfiguration;
  import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration("expert003.xml")
  public class CarTest {
    @Autowired
    Car car;	

    @Test
    public void 자동차_코리아타이어_장착_타이어브랜드_테스트() {		
      assertEquals("장착된 타이어: 코리아 타이어", car.getTireBrand());
    }
  }
  ```
- 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입
  - Car라고 하는 클래스에 tire라고 하는 속성을 만들고 설정자 메서드를 만든다고 가정
  ``` java
  Tire tire;
  
  public void setTire(Tire tire) {
    this.tire = tire;
  }
  ```
  - import문 하나와 @Autowired 애노테이션을 이용하면 설정자 메서드를 이용하지 않고도 종합쇼핑몰인 스프링 프레임워크가 설정 파일을 통해 설정자 메서드 대신 속성을 주입해줌
  ``` java
  import org.springframework.beans.factory.annotation.Autowired;
  
  @Autowired
  Tire tire;
  ```
  ``` xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">

    <context:annotation-config />

    <bean id="tire" class="expert004.KoreaTire"></bean>

    <bean id="wheel" class="expert004.AmericaTire"></bean>

    <bean id="car" class="expert004.Car"></bean>
  </beans>
  ```
    - xml에서 property 태그가 사라진 이유는 @Autowired를 통해 car의 property를 자동으로 엮어줄 수 있으므로(자동 의존성 주입) 생략이 가능
  ``` java
  import org.springframework.beans.factory.annotation.Autowired;
   
  public class Car {
    @Autowired
    Tire tire;

    public String getTireBrand() {
      return "장착된 타이어: " + tire.getBrand();
    }
  }
  ```
  - ![image](https://user-images.githubusercontent.com/61530368/176599400-856236e3-d014-47d6-9f65-7c98a2dae06c.png)
    - @Autowired는 type 기준 매칭으로 하기 때문에 bean 태그에서 id가 없어도 주입가능
    - 그러나 해당 타입이 여러개 구현되어 있다면 id로 지정해줘야한다 
    - 이렇게 하지않으면 여러개중 무엇을 주입해야하는 지 모르기 때문에 No unique bean 에러가 뜸
- 스프링을 통한 의존성 주입 - @Resource를 통한 속성 주입
  - @Resource는 자바 표준 어노테이션이다 
  - 스프링 프레임워크를 사용하지 않는다면 @Autowired는 사용할 수 없고 오직 @Resource만 사용해야함
  - @Autowired의 경우 type과 id 가운데 매칭 우선순위는 type이 높다
  - 반면 @Resource의 경우 type과 id가운데 매칭 순위는 id가 높다  

### AOP - Aspect
  - AOP 
    - 로직(code) 주입 
