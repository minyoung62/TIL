# 1 기초 정수론
##  1.1수체계
  - ![image](https://user-images.githubusercontent.com/61530368/172412019-81862edf-e6fb-4084-8f11-fdc29bf42c38.png)

##  1.2항등원과 역원
  - 항등원 
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, x가 나오게 하는 원소 y
    - 덧셈, 뺄셈 연산에 대한 항등원 -> 0 (x + y = x, x - y = x)
    - 곱셈, 나눗셈 연산에 대한 항등원 -> 1 (x * y = x, x/y = x)
  - 역원
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, 해당 연산의 항등원이 나오게 하는 원소 y
    - 덧셈 연산에 대한 역원 -> -x (x + y = 0, x - y = 0)
    - 곱셈 연산에 대한 역원 -> 1/x (x * y = 1, x/y = 1)  
##  1.3 정수 집합과 이항 연산
  - 정수 집합
    - 음의 무한대에서 양의 무한대까지의 모든 정수로 구성된 집합
    - Z = { -무한대, ..., -2, -1, 0, 1, 2,  ..., 무한대}
    - a, b ∈ Z : 임의의 두 정수 a와 b   
  - 이항 연산
    - 두 입력 값으로부터 하나의 결과 값을 산출하는 연산 
    - * 나눗셈은 연산 결과로 목과 나머지를 산출하므로, 이항 연산에 속하지 않는다 
##  1.4 나눗셈, 나눗셈 정리, 가분성
  - 나눗셈
    - a ∈ Z를 n ∈ Z (n != 0)으로 나누면
    - 목(quotient) : q ∈ Z
    - 나머지(remainder): r ∈ Z
    - a = qn + r
    - r = q - qn
    - 제한사항
      - n > 0 
      - r >= 0
      - a가 음수일 경우 q와 r은 음수이다 
      - 이 때, r이 음이 아닌 정수라는 제약사항일 때는  -> q에서 1을 빼고, r에 n을 더하여 음이 아닌 정수로 만든다    
    - 나눗셈은 이항 연산이 아닌 관계식이다
  - 나눗셈 정리 
    - 임의의 두 정수 a, b ∈ Z (b > 0)가 존재한다면, a = qb + r을 만족하는 두 정수 q,r ∈ Z이 항상 유일하게 존재한다 
  - 가분성
    - a를 n으로 나눌 때, 나머지가 0이라면, (즉, a = qn + r 에서 r = 0 )
    - n은 a의 약수(divisor)이다
    - a는 n으로 나눌 수 있다
    - n | a
    - 가분성 성질
      -  만약 a | 1 이면 a = +-1
      -  만약 a | b 이고 b | a 이면 a = +-b
      -  만약 a | b 이고 b | c 이면 a | c
      -  만약 a | b 이고 a | c 이면 a | (mb + nc) (m, n ∈ Z)
  - 약수
    - 양의 정수는 하나 이상의 약수를 갖는다
    - 정수 1은 하나의 약수, 즉 1만을 가진다
    - 모든 양의 정수는 최소 2개 이상의 약수를 가진다
  - 최대 공약수
    - 공약수 (Common divisor)
      - 두 양의 정수가 갖는 공통의 약수 
    - 최대 공약수 (Greatest Common Divisor: GCD)
      - 두 양의 정수의 공약수중에서 가장 큰 정수
      - 두 양의 정수의 최대 공약수 = 두 정수를 나누는 가장 큰 정수 
##  1.5 유클리드 알고리즘
  - 유클리드 알고리즘
    - 두 양의 정수의 최대 공약수를 찾는 알고리즘
    - 기본 원리
      - gcd(a, 0) = a
      - gcd(a, b) = gcd(b, r) (r = a를 b로 나눈 나머지)
    - 예시) 36과 10의 최대공약수를 유클리드 알고리즘으로 계산하라
    -   gcd(36, 10) = gcd(10, 6) = gcd(6, 4) = gcd(4, 2) = gcd(2, 0) = 2
  - 
##  1.6 확장 유클리드 알고리즘

# 2 기초 정수론
## 2.1 선형 디오판투스 방정식
## 2.2 모듈러 연산
  - 모듈러 연산
    - 나머지 연산의 두 결과 값 중 나머지 r(>= 0)만 출력하는 연산
    - 27 mod 5 = 2
    - -18 mod 14 = 10 
      - r > 0이어야 하므로, a = qn + r에서
      - q = q - 1
      - r = r + n
      - 을 통해 r을 양의 정수로 바꿀 수 있음 
## 2.3 최소 잉여 집합과 모듈러 합동
  - 최소 잉여 집합
    - 모듈로 n을 이용하는 모듈로 연산의 결과는 0 ~ n -1 사이의 값을 갖는다
    - 이때, 정수 n에 대한 모듈로 연산 결과는 하나의 집합을 생성하는데, 이 집합을 "모듈로 n의 최소 잉여 집합 Zn"이라 한다
    - Zn = {0,1,2, ..., (n-1)}
    - ex) Z2 = {0, 1}
    - ex) Z6 = {0, 1, 2, 3, 4, 5}
  - 모듈러 합동
    - 모듈로 연산에서 2, 12, 22, 52에 대해 "mod 10"을 수행하면
    - 2 mod 10 = 2
    - 12 mod 10 = 2
    - 22 mod 10 = 2
    - 52 mod 10 = 2
    - 즉, 모두 같은 결과 값 r = 2를 가진다
    - 이때, 2와 12, 22 그리고 52는 "mod 10"에 대하여 합동이다
    - 합동 연산자 "≡"
      - a ≡ b (mod x): 두 정수 a와 b는 "mod x"에 대하여 서로 합동이다
      - 즉, a와 b는 x로 나누었을 때, 서로 같은 나머지를 갖는다      
## 2.4 잉여류와 모듈러 연산의 성질
  - 잉여류(Residue classes)
    - n으로 합동인 정수의 집합
    - [a] 또는 [a]n으로 표기
      - 즉, [a]n은 n으로 나누었을 때, 나머지가 a가 되는 모든 정수들의 집합
    - ex) n = 5일 때 잉여류
      - [0] = 5로 나누었을 때 나머지가 0인 정수들의 집합
      - [1] = 5로 나누었을 때 나머지가 1인 정수들의 집합
      - [2] = 5로 나누었을 때 나머지가 2인 정수들의 집합
      - [3] = 5로 나누었을 때 나머지가 3인 정수들의 집합
      - 아래와 같이 표현함
      - [0] = {..., 0, 5, 10, 15,...}
      - [1] = {..., 6, 11, 16, ...} 
  - Zn에서의 연산
    - 잉여류 Zn에서 덧셈, 뺄셈, 곱셈 연산 수행 가능
    - Z15의 7과 14를 더하시오 -> (7 + 14) mod 15 -> 21 mod 15 = 6
  - 모듈러 연산의 성질
    - (a + b) mod n = [(a mod n) + (b mod n)] mod n
    - (a - b) mod n = [(a mod n) + (b mod n)] mod n
    - (a * b) mod n = [(a mod n) * (b mod n)] mod n
    - 암호 알고리즘에 모듈러 연산 적용 시 a와 b의 값은 일반적으로 매우 큰 수
    - 따라서, 계산 시 발생하는 오버헤드를 모듈러 연산의 성질로 완화할 수 있다
## 2.5 모듈러 역원
  - 덧셈에 대한 역원
    - 모듈러 연산에서 각각의 정수는 덧셈에 대한 역원을 갖는다
    - 어떤 정수와 그 정수의 덧셈에 대한 역원의 합은 모듈로 n에 대하여 0과 합동이다
    - 즉, Zn에서 두 수 a와 b는 다음과 같이 서로 덧셈에 대한 역원이 된다
      - a + b ≡ 0 mod n 
    - 따라서, Zn에서 a의 덧셈에 대한 역원은 b = n - a
    - ex ) Z10에서 모든 덧셈에 대한 역원 쌍
      - 덧셈에 대한 역원의 쌍 총 6개
      - (0,0), (1, 9), (2, 8), (3, 7), (4, 6), (5, 5)
  - 곱셈에 대한 역원
    - 즉, Zn에서 두 수 a와 b가 아래의 성질을 만족하면 이들은 서로 곱셈에 대한 역원이 된다
      - a * b ≡ 1 mod n
    - 모듈로 연산에서 정수는 곱셈에 대한 역원이 있을 수도 있고, 없을 수도 있음
    - 만약 곱셈에 대한 역원이 있따면, 그 정수와 해당하는 곱셈에 대한 역원의 곲은 모듈로 n에서 1과 합동
    - a가 Zn에서 곱셈에 대한 역원을 갖기 위한 필요충분조건
      - gcd(n, a) = 1
    - 이 경우 n과 a는 서로소이다
      - 서로소란 두 수 a와 b의 최대공약수가 1일 때, 두 수는 서로소이다
    - ex) Z10에서 곱셈에 대한 역원
      - (1, 1), (3, 7), (9, 9)
      - (1 * 1) mod 10 = 1
      - (3 * 7) mod 10 = 1
      - (9 * 9) mod 10 = 1 
# 3 고전 대칭 키 암호
## 3.1 대칭 키 암호의 기본 개념
  - Kerchoff의 원리
    - 암호체계의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되며
    - 키의 비밀을 지키는데 의존되어야 한다
  - 용어 설명
    - 평문(Plaintext): 송신자가 수신자에게 보내는 본래의 메시지
    - 암호 알고리즘(Encryption algorithm): 평문을 암호문으로 변경하는 알고리즘
    - 복호 알고리즘(Decryption algorithm): 암호문을 평문으로 복원하는 알고리즘
    - 공유 비밀 키(Shared secret key): 송신자와 수신자가 함께 공유하는 암호화와 복호화에 사용되는 값
    - 암호(Cipher): 암호 알고리즘과 복호 알고리즘을 통칭 
  - 대칭 키 암호체계의 특징
    - 송신자와 수신자가 비밀 키를 공유함 즉, 암호 키와 복호 키가 동일 
    - ![image](https://user-images.githubusercontent.com/61530368/172433820-e3f5f460-3ed6-4160-9799-ffa0d259e8bc.png)
  - 고전 대칭 키 암호체계의 종류
    - 대치 암호: 평문(암호문)내 각 기호를 다른 기호로 치환하여 암호(복호화) 수행
    - 전치 암호: 평문(암호문)내 각 기호의 위치를 다른 위치로 변환하여 암호화(복호화) 수행   
## 3.2 대치 암호
  - 대치 암호란?
    - 하나의 기호를 다른 기호로 대체하여 암호화/복호화 수행
    - 대치암호는 단일문자암호, 다중문자 암호로 분류 
    - 단일 문자 암호
      - 평문에서 하나의 문자(기호)가 위치에 상관없이 암호문에서 항상 같은 문자(기호)로 대체
      - 항상 일대일 대응 관계를 갖는 암호체계 
## 3.2 전치 암호
## 3.4 스트림 암호와 블록 암호

# 4 암호 공격의 기본 개념
## 4.1 암호 공격의 개념
  - 암호 공격
    - 송신자와 수신자 이외의 허가 받지 않은 제3자가 암호 시스템을 공격하여 공개되지 않은 키를 불법적으로 회득하거나, 이를 이용하여 암호문의 내용을 가로채는 행위
    ![image](https://user-images.githubusercontent.com/61530368/172436471-0ae167fa-830e-4823-adee-66d6e5278aa3.png)
  - 수동적 공격
    - 메시지의 도청: 공격자가 전송되는 메시지를 도중에 가로채어 그 내용을 외부로 노출시키는 공격, 메시지의 내용을 공격하는 개념
  - 트래픽 분석
    - 존송 메시지의 암호화로 도청을 통한 메시지 내용 파악이 불가능한 경우, 송신자와 수신자의 메시지 전송 트래픽을 분석하여 암호문의 내용을 가로채어 해독하거나 이를 공개하는 개념
  - 능동적 공격
    - 메시지 변조: 전송되는 메시지 순서바꿈, 일부분을 다른 멧지ㅣ로 대체하여 불법적인 효과 발생
    - 삽입 공격: 공격자가 정당한 송신자로 가장 특정 수신자에게 메시지를 보내어 불법적인 효과를 발생
    - 삭제 공격: 정상적인 통신 시설의 사용과 관리를 방해하는 서비스 거부 등을 통해, 특정 수신자에게 전송되는 메시지의 전부 또는 일부를 삭제하는 공격
    - 재생 공격: 공격자가 이전에 특정 송신자와 수신자 간에 행해졌던 통화내용을 도청하여 보관 나중에 재생하여 전송하는 공격 
  - 암호 공격 방식
    - 암호문 단독 공격: 공격자는 단지 암호문만 갖고 있음 이로부터 평문 또는 키를 찾음
    - 기지 평문 공격: 공격자는 일정량의 평문에 대응하는 암호문을 알고 있는 상태에서 암호문의 내용을 해독하는 방법
    - 선택 평문 공격: 공격자가 암호 시스템에 접근하여 평문을 선택, 해당 평문에 해당하는 암호문을 회득한 후, 키 또는 평문을 추정하여 암호문의 내용을 해독
    - 선택 암호문 공격: 공격자가 암호 복호기에 접근하여 암호문에 대한 평문을 회득하여 암호를 해독
  - 암호 시스템의 안전성
    - 계산적 안전성: 암호 시스템을 공격하기 위해 필요한 계산량이 매우 많아서 현실적으로 공격할 수 없는 경우
    - 증명 가능한 안전성: 암호 시스템에서 사용중인 암/복호화 알고리즘이 어렵다고 알려진 문제와 등가라서 현실적으로 해결(공격)할 수 업슨ㄴ 경우
    - 절대적 안전성: 무한한 계산능력을 보유하고 있어도 암호 시스템을 공격할 수 없는 경우(= 무조건적 안전성)
  - 암호 알고리즘 개발자의 목표
    - 암호 해독 비용이 암호화된 정보의 가치를 초과할 수 있는 알고리즘 개발
    - 암호 해독 시간이 암호화된 정보의 유효 기간을 초과할 수 있는 알고리즘    
## 4.2 암호 공격 방법
  - 전수조사 공격 
    - 공격자는 키의 집합을 미리 알고 있다고 가정
    - 모든 가능한 키를 사용 암호문을 복호화하며, 의미 있는 평문이 도출 될 때 까지 이를 반복
  - 통계적인 공격(Statistical attack)
    - 공격자가 평문 언어의 고유한 특징으로부터 정보를 얻음
    - 예를 들어, 평문이 영어일 때 공격자는 암호문에서 가장 빈번하게 사용  
  - 패턴 공격
    - 평문 언어의 특징은 드러나지 않지만 암호문에 어떤 패턴이 존재할 경우, 이를 분석하여 키 유추
  - 암호문 단독 공격
    - 공격자는 암호문 C만을 갖고 있는 상황
    - 공격자가 암호문 C로부터 평문 P또는 키 K를 찾아내는 방법
    - ![image](https://user-images.githubusercontent.com/61530368/172549206-c365ab46-7783-4b51-b4c4-73b4fcfffdc0.png)
  - 기지 평문 공격 (Known plain text attack)
    - 기지 평문 공격(=알려진 평문 공격)은 공격자가 평문과 암호문을 모두 알고 있을 때 사용할 수 있는 암호 해독 기법
    - 즉, 공격자는 일정량의 평문 P에 대응하는 암호문 C를 알고 있을 때
    - 이 때, 공격자는 암호문 C와 평문 P의 관계로부터 키 K나 복호화 알고리즘을 추정 가능
    - 따라서, 기지 평문 공격의 최종 목표는 복호키를 찾는 것
    - ![image](https://user-images.githubusercontent.com/61530368/172549632-3953cdf3-0e70-40d9-9d80-5362f4dcb8f4.png)
  - 선택 평문 공격
    - 공격자가 많은 수의 평문을 암호문으로 만들 수 있는 상태(단, 암호 알고리즘이나 키에 대한 정보는 모르는 상태)에서 공격하는 유형
    -  ![image](https://user-images.githubusercontent.com/61530368/172549834-c57577aa-4297-43d6-bbe0-d137c344c8a8.png)

  - 선택 암호문 공격
    - 공격자가 임의로 선택된 암호문과 일치하는 평문으로부터 암호키를 알아내기 위해 시도하는 공격
    - 공격자가 많은 수의 암호문에 대한 평문을 확보한 상태에서 시도하는 공격 유형
    - ![image](https://user-images.githubusercontent.com/61530368/172550087-748e72d9-0da0-466d-8073-3ffe8f793e6e.png)  
## 4.3 고전 암호의 공격 방법
  - 단일치환 암호의 공격
  - Vigenere 암호의 공격
  - Hill Climbing Method
# 현대 블록 암호 
## 현대 블록 암호의 특징
  - 연산의 단위: 비트 단위로 수행
    - 한번에 n비트 평문 블록을 암호화/복호화
    - 평문이 n비트보다 크면 분할, 작으면 n비트가 되도록 패딩(덧붙이기)
    - 보통 n = 64, 128, 256, 512비트 등
    - 암호/복호 알고리즘은 동일한 k비트 비밀키를 사용
    - 복호 알고리즘은 암호 알고리즘의 역함수 
  - 대치와 전치
    - 현대 암호 체계는 대치(Substitution) 암호와 전치(Transposition)암호를 조합하여 동작하도록 설계
    - 특히, 현대 블록 암호는 전수조사 공격에 안전하기 위하여 대치 암호를 사용하여 설계
      - 전치 암호로만 설계하면 평문과 암호문에서 0과 1의 개수가 동일
      
## Simplified-Data Encryption Standard (S-DES)
  - DES 개요
    - IBM에서 Lucifer System을 개선하여 개발
    - 특징
      - 64비트 블럭 암호 알고리즘
      - 56비트 키를 사용: 64비트 중 8비트는 parity check로 사용
      - 라운드 수: 16 라운드
      - 복호화는 암호화의 역순
  - S-DES
    - 개요   
      - Simplified-DES의 약자
      - 교육용 알고리즘
      - 8비트 평문 블럭과 10비트 키를 사용
      - ![image](https://user-images.githubusercontent.com/61530368/172553263-36f0e527-83cb-454d-83e3-e5800a72ca23.png)
      - IP(initial Permutation): 초기 순열
      - 함수 fk: 각 비트별로 전치(transposition)와 치환(substitution) 연산 수행
      - SW: 각 데이터의 절반을 상호 교환하는 함수
      - IP^-1(Inverse Initial Permutation): 초기 순열의 역순인 순열 함수  
  - 암호화 과정
    - Ciphertext = IP^-1(fk2(SW(fk1(IP(Plaintext)))))
  - 복호화 과정
    - Plain = IP^-1(fk1(SW(fk2(IP(Ciphertext)))))
  - 키 생성 
    - S-DES는 10-bit Key를 사용, sub-key로써 두 개의 8-bit sub key
    - ex) P10 (1010000010) -> (1000001100)
    - ![image](https://user-images.githubusercontent.com/61530368/172554665-3a2eefc6-f6e2-482b-b1b1-61eb294aad99.png)
  - LS-1
    -  1비트 Circular Left Shift연산 : ex) 10001 -> 00011
  - 함수 fk
    - 전치와 치환연산 수행
    -   ![image](https://user-images.githubusercontent.com/61530368/172555684-aacfe83b-580d-4c7b-b99e-a8966c3347dd.png)
  - S-DES 분석
    - 전수조사(Brute force) 공격 가능
      - 10비트 키로 단지 2^10가지의 가능성이 존재하므로 전수조사 공격이 충분히 가능  

## 현대 블록 암호의 구성 요소
  - 현대 블록암호의 주요 구성 요소
    - 전치요소 (P-Box)
    - 대치요소 (S-Box)
    - 그 밖의 구성 요소들(XOR, Shift, Swap 등)
    - 위 3개를 결합하여 설계
  - P-Box
    - 문자 단위로 수행하였던 고전 전치 암호를 비트 단위로 수행
    - 세 종류의 P-Box가 존재
      - 단순(Straight) P-Box
      - 확장(Expansion) P-Box
      - 축소(Compression) P-Box
  - 단순 P-Box
    - n비트 길이의 워드를 입력 받아 n비트 길이의 출력하는 치환(permutation)함수
    - ![image](https://user-images.githubusercontent.com/61530368/172556596-0be89cf9-b6ca-443e-92dd-f97e004959ef.png)

  - 축소 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이의 워드(n > m)를 출력하는 P-Box
    - ![image](https://user-images.githubusercontent.com/61530368/172556739-099561c7-63d0-4978-815d-019175e8e943.png)
  - 확장 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이(n < m)의 워드로 출력하는 P-Box  
    - ![image](https://user-images.githubusercontent.com/61530368/172556907-ecb2879d-9fd9-4660-b1c2-618e0001296c.png)
  - P-Box의 역함수 존재성
    - 단순 P-Box는 입력 워드와 출력 워드의 비트간의 관계가 일대일 대응이므로 역함수 존재
    - 그러나, 축소 P-Box와 확장 P-Box는 일대일 대응이 아니므로 역함수가 존재하지 않음
  - S-Box
    - S-Box는 대치 암호를 나타냄
    - S-Box는 입력과 출력의 개수가 달라도 됨
    - S-Box는 m*n 대치 단위로 정의되며, 이 때 m과 n이 반드시 같을 필요는 없음  
    - ![image](https://user-images.githubusercontent.com/61530368/172557563-6ba60ddb-b10c-465a-9ad7-6847d8d41e74.png)

## 합성 암를 생성












