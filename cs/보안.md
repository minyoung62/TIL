# 1 기초 정수론
##  1.1수체계
  - ![image](https://user-images.githubusercontent.com/61530368/172412019-81862edf-e6fb-4084-8f11-fdc29bf42c38.png)

##  1.2항등원과 역원
  - 항등원 
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, x가 나오게 하는 원소 y
    - 덧셈, 뺄셈 연산에 대한 항등원 -> 0 (x + y = x, x - y = x)
    - 곱셈, 나눗셈 연산에 대한 항등원 -> 1 (x * y = x, x/y = x)
  - 역원
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, 해당 연산의 항등원이 나오게 하는 원소 y
    - 덧셈 연산에 대한 역원 -> -x (x + y = 0, x - y = 0)
    - 곱셈 연산에 대한 역원 -> 1/x (x * y = 1, x/y = 1)  
##  1.3 정수 집합과 이항 연산
  - 정수 집합
    - 음의 무한대에서 양의 무한대까지의 모든 정수로 구성된 집합
    - Z = { -무한대, ..., -2, -1, 0, 1, 2,  ..., 무한대}
    - a, b ∈ Z : 임의의 두 정수 a와 b   
  - 이항 연산
    - 두 입력 값으로부터 하나의 결과 값을 산출하는 연산 
    - * 나눗셈은 연산 결과로 목과 나머지를 산출하므로, 이항 연산에 속하지 않는다 
##  1.4 나눗셈, 나눗셈 정리, 가분성
  - 나눗셈
    - a ∈ Z를 n ∈ Z (n != 0)으로 나누면
    - 목(quotient) : q ∈ Z
    - 나머지(remainder): r ∈ Z
    - a = qn + r
    - r = q - qn
    - 제한사항
      - n > 0 
      - r >= 0
      - a가 음수일 경우 q와 r은 음수이다 
      - 이 때, r이 음이 아닌 정수라는 제약사항일 때는  -> q에서 1을 빼고, r에 n을 더하여 음이 아닌 정수로 만든다    
    - 나눗셈은 이항 연산이 아닌 관계식이다
  - 나눗셈 정리 
    - 임의의 두 정수 a, b ∈ Z (b > 0)가 존재한다면, a = qb + r을 만족하는 두 정수 q,r ∈ Z이 항상 유일하게 존재한다 
  - 가분성
    - a를 n으로 나눌 때, 나머지가 0이라면, (즉, a = qn + r 에서 r = 0 )
    - n은 a의 약수(divisor)이다
    - a는 n으로 나눌 수 있다
    - n | a
    - 가분성 성질
      -  만약 a | 1 이면 a = +-1
      -  만약 a | b 이고 b | a 이면 a = +-b
      -  만약 a | b 이고 b | c 이면 a | c
      -  만약 a | b 이고 a | c 이면 a | (mb + nc) (m, n ∈ Z)
  - 약수
    - 양의 정수는 하나 이상의 약수를 갖는다
    - 정수 1은 하나의 약수, 즉 1만을 가진다
    - 모든 양의 정수는 최소 2개 이상의 약수를 가진다
  - 최대 공약수
    - 공약수 (Common divisor)
      - 두 양의 정수가 갖는 공통의 약수 
    - 최대 공약수 (Greatest Common Divisor: GCD)
      - 두 양의 정수의 공약수중에서 가장 큰 정수
      - 두 양의 정수의 최대 공약수 = 두 정수를 나누는 가장 큰 정수 
##  1.5 유클리드 알고리즘
  - 유클리드 알고리즘
    - 두 양의 정수의 최대 공약수를 찾는 알고리즘
    - 기본 원리
      - gcd(a, 0) = a
      - gcd(a, b) = gcd(b, r) (r = a를 b로 나눈 나머지)
    - 예시) 36과 10의 최대공약수를 유클리드 알고리즘으로 계산하라
    -   gcd(36, 10) = gcd(10, 6) = gcd(6, 4) = gcd(4, 2) = gcd(2, 0) = 2
  - 
##  1.6 확장 유클리드 알고리즘

# 2 기초 정수론
## 2.1 선형 디오판투스 방정식
## 2.2 모듈러 연산
  - 모듈러 연산
    - 나머지 연산의 두 결과 값 중 나머지 r(>= 0)만 출력하는 연산
    - 27 mod 5 = 2
    - -18 mod 14 = 10 
      - r > 0이어야 하므로, a = qn + r에서
      - q = q - 1
      - r = r + n
      - 을 통해 r을 양의 정수로 바꿀 수 있음 
## 2.3 최소 잉여 집합과 모듈러 합동
  - 최소 잉여 집합
    - 모듈로 n을 이용하는 모듈로 연산의 결과는 0 ~ n -1 사이의 값을 갖는다
    - 이때, 정수 n에 대한 모듈로 연산 결과는 하나의 집합을 생성하는데, 이 집합을 "모듈로 n의 최소 잉여 집합 Zn"이라 한다
    - Zn = {0,1,2, ..., (n-1)}
    - ex) Z2 = {0, 1}
    - ex) Z6 = {0, 1, 2, 3, 4, 5}
  - 모듈러 합동
    - 모듈로 연산에서 2, 12, 22, 52에 대해 "mod 10"을 수행하면
    - 2 mod 10 = 2
    - 12 mod 10 = 2
    - 22 mod 10 = 2
    - 52 mod 10 = 2
    - 즉, 모두 같은 결과 값 r = 2를 가진다
    - 이때, 2와 12, 22 그리고 52는 "mod 10"에 대하여 합동이다
    - 합동 연산자 "≡"
      - a ≡ b (mod x): 두 정수 a와 b는 "mod x"에 대하여 서로 합동이다
      - 즉, a와 b는 x로 나누었을 때, 서로 같은 나머지를 갖는다      
## 2.4 잉여류와 모듈러 연산의 성질
  - 잉여류(Residue classes)
    - n으로 합동인 정수의 집합
    - [a] 또는 [a]n으로 표기
      - 즉, [a]n은 n으로 나누었을 때, 나머지가 a가 되는 모든 정수들의 집합
    - ex) n = 5일 때 잉여류
      - [0] = 5로 나누었을 때 나머지가 0인 정수들의 집합
      - [1] = 5로 나누었을 때 나머지가 1인 정수들의 집합
      - [2] = 5로 나누었을 때 나머지가 2인 정수들의 집합
      - [3] = 5로 나누었을 때 나머지가 3인 정수들의 집합
      - 아래와 같이 표현함
      - [0] = {..., 0, 5, 10, 15,...}
      - [1] = {..., 6, 11, 16, ...} 
  - Zn에서의 연산
    - 잉여류 Zn에서 덧셈, 뺄셈, 곱셈 연산 수행 가능
    - Z15의 7과 14를 더하시오 -> (7 + 14) mod 15 -> 21 mod 15 = 6
  - 모듈러 연산의 성질
    - (a + b) mod n = [(a mod n) + (b mod n)] mod n
    - (a - b) mod n = [(a mod n) + (b mod n)] mod n
    - (a * b) mod n = [(a mod n) * (b mod n)] mod n
    - 암호 알고리즘에 모듈러 연산 적용 시 a와 b의 값은 일반적으로 매우 큰 수
    - 따라서, 계산 시 발생하는 오버헤드를 모듈러 연산의 성질로 완화할 수 있다
## 2.5 모듈러 역원
  - 덧셈에 대한 역원
    - 모듈러 연산에서 각각의 정수는 덧셈에 대한 역원을 갖는다
    - 어떤 정수와 그 정수의 덧셈에 대한 역원의 합은 모듈로 n에 대하여 0과 합동이다
    - 즉, Zn에서 두 수 a와 b는 다음과 같이 서로 덧셈에 대한 역원이 된다
      - a + b ≡ 0 mod n 
    - 따라서, Zn에서 a의 덧셈에 대한 역원은 b = n - a
    - ex ) Z10에서 모든 덧셈에 대한 역원 쌍
      - 덧셈에 대한 역원의 쌍 총 6개
      - (0,0), (1, 9), (2, 8), (3, 7), (4, 6), (5, 5)
  - 곱셈에 대한 역원
    - 즉, Zn에서 두 수 a와 b가 아래의 성질을 만족하면 이들은 서로 곱셈에 대한 역원이 된다
      - a * b ≡ 1 mod n
    - 모듈로 연산에서 정수는 곱셈에 대한 역원이 있을 수도 있고, 없을 수도 있음
    - 만약 곱셈에 대한 역원이 있따면, 그 정수와 해당하는 곱셈에 대한 역원의 곲은 모듈로 n에서 1과 합동
    - a가 Zn에서 곱셈에 대한 역원을 갖기 위한 필요충분조건
      - gcd(n, a) = 1
    - 이 경우 n과 a는 서로소이다
      - 서로소란 두 수 a와 b의 최대공약수가 1일 때, 두 수는 서로소이다
    - ex) Z10에서 곱셈에 대한 역원
      - (1, 1), (3, 7), (9, 9)
      - (1 * 1) mod 10 = 1
      - (3 * 7) mod 10 = 1
      - (9 * 9) mod 10 = 1 
# 3 고전 대칭 키 암호
## 3.1 대칭 키 암호의 기본 개념
  - Kerchoff의 원리
    - 암호체계의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되며
    - 키의 비밀을 지키는데 의존되어야 한다
  - 용어 설명
    - 평문(Plaintext): 송신자가 수신자에게 보내는 본래의 메시지
    - 암호 알고리즘(Encryption algorithm): 평문을 암호문으로 변경하는 알고리즘
    - 복호 알고리즘(Decryption algorithm): 암호문을 평문으로 복원하는 알고리즘
    - 공유 비밀 키(Shared secret key): 송신자와 수신자가 함께 공유하는 암호화와 복호화에 사용되는 값
    - 암호(Cipher): 암호 알고리즘과 복호 알고리즘을 통칭 
  - 대칭 키 암호체계의 특징
    - 송신자와 수신자가 비밀 키를 공유함 즉, 암호 키와 복호 키가 동일 
    - ![image](https://user-images.githubusercontent.com/61530368/172433820-e3f5f460-3ed6-4160-9799-ffa0d259e8bc.png)
  - 고전 대칭 키 암호체계의 종류
    - 대치 암호: 평문(암호문)내 각 기호를 다른 기호로 치환하여 암호(복호화) 수행
    - 전치 암호: 평문(암호문)내 각 기호의 위치를 다른 위치로 변환하여 암호화(복호화) 수행   
## 3.2 대치 암호
  - 대치 암호란?
    - 하나의 기호를 다른 기호로 대체하여 암호화/복호화 수행
    - 대치암호는 단일문자암호, 다중문자 암호로 분류 
    - 단일 문자 암호
      - 평문에서 하나의 문자(기호)가 위치에 상관없이 암호문에서 항상 같은 문자(기호)로 대체
      - 항상 일대일 대응 관계를 갖는 암호체계 
## 3.2 전치 암호
## 3.4 스트림 암호와 블록 암호

# 4 암호 공격의 기본 개념
## 4.1 암호 공격의 개념
  - 암호 공격
    - 송신자와 수신자 이외의 허가 받지 않은 제3자가 암호 시스템을 공격하여 공개되지 않은 키를 불법적으로 회득하거나, 이를 이용하여 암호문의 내용을 가로채는 행위
    ![image](https://user-images.githubusercontent.com/61530368/172436471-0ae167fa-830e-4823-adee-66d6e5278aa3.png)
  - 수동적 공격
    - 메시지의 도청: 공격자가 전송되는 메시지를 도중에 가로채어 그 내용을 외부로 노출시키는 공격, 메시지의 내용을 공격하는 개념
  - 트래픽 분석
    - 존송 메시지의 암호화로 도청을 통한 메시지 내용 파악이 불가능한 경우, 송신자와 수신자의 메시지 전송 트래픽을 분석하여 암호문의 내용을 가로채어 해독하거나 이를 공개하는 개념
  - 능동적 공격
    - 메시지 변조: 전송되는 메시지 순서바꿈, 일부분을 다른 멧지ㅣ로 대체하여 불법적인 효과 발생
    - 삽입 공격: 공격자가 정당한 송신자로 가장 특정 수신자에게 메시지를 보내어 불법적인 효과를 발생
    - 삭제 공격: 정상적인 통신 시설의 사용과 관리를 방해하는 서비스 거부 등을 통해, 특정 수신자에게 전송되는 메시지의 전부 또는 일부를 삭제하는 공격
    - 재생 공격: 공격자가 이전에 특정 송신자와 수신자 간에 행해졌던 통화내용을 도청하여 보관 나중에 재생하여 전송하는 공격 
  - 암호 공격 방식
    - 암호문 단독 공격: 공격자는 단지 암호문만 갖고 있음 이로부터 평문 또는 키를 찾음
    - 기지 평문 공격: 공격자는 일정량의 평문에 대응하는 암호문을 알고 있는 상태에서 암호문의 내용을 해독하는 방법
    - 선택 평문 공격: 공격자가 암호 시스템에 접근하여 평문을 선택, 해당 평문에 해당하는 암호문을 회득한 후, 키 또는 평문을 추정하여 암호문의 내용을 해독
    - 선택 암호문 공격: 공격자가 암호 복호기에 접근하여 암호문에 대한 평문을 회득하여 암호를 해독
  - 암호 시스템의 안전성
    - 계산적 안전성: 암호 시스템을 공격하기 위해 필요한 계산량이 매우 많아서 현실적으로 공격할 수 없는 경우
    - 증명 가능한 안전성: 암호 시스템에서 사용중인 암/복호화 알고리즘이 어렵다고 알려진 문제와 등가라서 현실적으로 해결(공격)할 수 업슨ㄴ 경우
    - 절대적 안전성: 무한한 계산능력을 보유하고 있어도 암호 시스템을 공격할 수 없는 경우(= 무조건적 안전성)
  - 암호 알고리즘 개발자의 목표
    - 암호 해독 비용이 암호화된 정보의 가치를 초과할 수 있는 알고리즘 개발
    - 암호 해독 시간이 암호화된 정보의 유효 기간을 초과할 수 있는 알고리즘    
## 4.2 암호 공격 방법
  
## 4.3 고전 암호의 공격 방법

