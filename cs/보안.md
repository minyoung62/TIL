# 1 기초 정수론
##  1.1수체계
  - ![image](https://user-images.githubusercontent.com/61530368/172412019-81862edf-e6fb-4084-8f11-fdc29bf42c38.png)

##  1.2항등원과 역원
  - 항등원 
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, x가 나오게 하는 원소 y
    - 덧셈, 뺄셈 연산에 대한 항등원 -> 0 (x + y = x, x - y = x)
    - 곱셈, 나눗셈 연산에 대한 항등원 -> 1 (x * y = x, x/y = x)
  - 역원
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, 해당 연산의 항등원이 나오게 하는 원소 y
    - 덧셈 연산에 대한 역원 -> -x (x + y = 0, x - y = 0)
    - 곱셈 연산에 대한 역원 -> 1/x (x * y = 1, x/y = 1)  
##  1.3 정수 집합과 이항 연산
  - 정수 집합
    - 음의 무한대에서 양의 무한대까지의 모든 정수로 구성된 집합
    - Z = { -무한대, ..., -2, -1, 0, 1, 2,  ..., 무한대}
    - a, b ∈ Z : 임의의 두 정수 a와 b   
  - 이항 연산
    - 두 입력 값으로부터 하나의 결과 값을 산출하는 연산 
    - * 나눗셈은 연산 결과로 목과 나머지를 산출하므로, 이항 연산에 속하지 않는다 
##  1.4 나눗셈, 나눗셈 정리, 가분성
  - 나눗셈
    - a ∈ Z를 n ∈ Z (n != 0)으로 나누면
    - 목(quotient) : q ∈ Z
    - 나머지(remainder): r ∈ Z
    - a = qn + r
    - r = q - qn
    - 제한사항
      - n > 0 
      - r >= 0
      - a가 음수일 경우 q와 r은 음수이다 
      - 이 때, r이 음이 아닌 정수라는 제약사항일 때는  -> q에서 1을 빼고, r에 n을 더하여 음이 아닌 정수로 만든다    
    - 나눗셈은 이항 연산이 아닌 관계식이다
  - 나눗셈 정리 
    - 임의의 두 정수 a, b ∈ Z (b > 0)가 존재한다면, a = qb + r을 만족하는 두 정수 q,r ∈ Z이 항상 유일하게 존재한다 
  - 가분성
    - a를 n으로 나눌 때, 나머지가 0이라면, (즉, a = qn + r 에서 r = 0 )
    - n은 a의 약수(divisor)이다
    - a는 n으로 나눌 수 있다
    - n | a
    - 가분성 성질
      -  만약 a | 1 이면 a = +-1
      -  만약 a | b 이고 b | a 이면 a = +-b
      -  만약 a | b 이고 b | c 이면 a | c
      -  만약 a | b 이고 a | c 이면 a | (mb + nc) (m, n ∈ Z)
  - 약수
    - 양의 정수는 하나 이상의 약수를 갖는다
    - 정수 1은 하나의 약수, 즉 1만을 가진다
    - 모든 양의 정수는 최소 2개 이상의 약수를 가진다
  - 최대 공약수
    - 공약수 (Common divisor)
      - 두 양의 정수가 갖는 공통의 약수 
    - 최대 공약수 (Greatest Common Divisor: GCD)
      - 두 양의 정수의 공약수중에서 가장 큰 정수
      - 두 양의 정수의 최대 공약수 = 두 정수를 나누는 가장 큰 정수 
##  1.5 유클리드 알고리즘
  - 유클리드 알고리즘
    - 두 양의 정수의 최대 공약수를 찾는 알고리즘
    - 기본 원리
      - gcd(a, 0) = a
      - gcd(a, b) = gcd(b, r) (r = a를 b로 나눈 나머지)
    - 예시) 36과 10의 최대공약수를 유클리드 알고리즘으로 계산하라
    -   gcd(36, 10) = gcd(10, 6) = gcd(6, 4) = gcd(4, 2) = gcd(2, 0) = 2
  - 
##  1.6 확장 유클리드 알고리즘

# 2 기초 정수론
## 2.1 선형 디오판투스 방정식
## 2.2 모듈러 연산
  - 모듈러 연산
    - 나머지 연산의 두 결과 값 중 나머지 r(>= 0)만 출력하는 연산
    - 27 mod 5 = 2
    - -18 mod 14 = 10 
      - r > 0이어야 하므로, a = qn + r에서
      - q = q - 1
      - r = r + n
      - 을 통해 r을 양의 정수로 바꿀 수 있음 
## 2.3 최소 잉여 집합과 모듈러 합동
  - 최소 잉여 집합
    - 모듈로 n을 이용하는 모듈로 연산의 결과는 0 ~ n -1 사이의 값을 갖는다
    - 이때, 정수 n에 대한 모듈로 연산 결과는 하나의 집합을 생성하는데, 이 집합을 "모듈로 n의 최소 잉여 집합 Zn"이라 한다
    - Zn = {0,1,2, ..., (n-1)}
    - ex) Z2 = {0, 1}
    - ex) Z6 = {0, 1, 2, 3, 4, 5}
  - 모듈러 합동
    - 모듈로 연산에서 2, 12, 22, 52에 대해 "mod 10"을 수행하면
    - 2 mod 10 = 2
    - 12 mod 10 = 2
    - 22 mod 10 = 2
    - 52 mod 10 = 2
    - 즉, 모두 같은 결과 값 r = 2를 가진다
    - 이때, 2와 12, 22 그리고 52는 "mod 10"에 대하여 합동이다
    - 합동 연산자 "≡"
      - a ≡ b (mod x): 두 정수 a와 b는 "mod x"에 대하여 서로 합동이다
      - 즉, a와 b는 x로 나누었을 때, 서로 같은 나머지를 갖는다      
## 2.4 잉여류와 모듈러 연산의 성질
  - 잉여류(Residue classes)
    - n으로 합동인 정수의 집합
    - [a] 또는 [a]n으로 표기
      - 즉, [a]n은 n으로 나누었을 때, 나머지가 a가 되는 모든 정수들의 집합
    - ex) n = 5일 때 잉여류
      - [0] = 5로 나누었을 때 나머지가 0인 정수들의 집합
      - [1] = 5로 나누었을 때 나머지가 1인 정수들의 집합
      - [2] = 5로 나누었을 때 나머지가 2인 정수들의 집합
      - [3] = 5로 나누었을 때 나머지가 3인 정수들의 집합
      - 아래와 같이 표현함
      - [0] = {..., 0, 5, 10, 15,...}
      - [1] = {..., 6, 11, 16, ...} 
  - Zn에서의 연산
    - 잉여류 Zn에서 덧셈, 뺄셈, 곱셈 연산 수행 가능
    - Z15의 7과 14를 더하시오 -> (7 + 14) mod 15 -> 21 mod 15 = 6
  - 모듈러 연산의 성질
    - (a + b) mod n = [(a mod n) + (b mod n)] mod n
    - (a - b) mod n = [(a mod n) + (b mod n)] mod n
    - (a * b) mod n = [(a mod n) * (b mod n)] mod n
    - 암호 알고리즘에 모듈러 연산 적용 시 a와 b의 값은 일반적으로 매우 큰 수
    - 따라서, 계산 시 발생하는 오버헤드를 모듈러 연산의 성질로 완화할 수 있다
## 2.5 모듈러 역원
  - 덧셈에 대한 역원
    - 모듈러 연산에서 각각의 정수는 덧셈에 대한 역원을 갖는다
    - 어떤 정수와 그 정수의 덧셈에 대한 역원의 합은 모듈로 n에 대하여 0과 합동이다
    - 즉, Zn에서 두 수 a와 b는 다음과 같이 서로 덧셈에 대한 역원이 된다
      - a + b ≡ 0 mod n 
    - 따라서, Zn에서 a의 덧셈에 대한 역원은 b = n - a
    - ex ) Z10에서 모든 덧셈에 대한 역원 쌍
      - 덧셈에 대한 역원의 쌍 총 6개
      - (0,0), (1, 9), (2, 8), (3, 7), (4, 6), (5, 5)
  - 곱셈에 대한 역원
    - 즉, Zn에서 두 수 a와 b가 아래의 성질을 만족하면 이들은 서로 곱셈에 대한 역원이 된다
      - a * b ≡ 1 mod n
    - 모듈로 연산에서 정수는 곱셈에 대한 역원이 있을 수도 있고, 없을 수도 있음
    - 만약 곱셈에 대한 역원이 있따면, 그 정수와 해당하는 곱셈에 대한 역원의 곲은 모듈로 n에서 1과 합동
    - a가 Zn에서 곱셈에 대한 역원을 갖기 위한 필요충분조건
      - gcd(n, a) = 1
    - 이 경우 n과 a는 서로소이다
      - 서로소란 두 수 a와 b의 최대공약수가 1일 때, 두 수는 서로소이다
    - ex) Z10에서 곱셈에 대한 역원
      - (1, 1), (3, 7), (9, 9)
      - (1 * 1) mod 10 = 1
      - (3 * 7) mod 10 = 1
      - (9 * 9) mod 10 = 1 
# 3 고전 대칭 키 암호
## 3.1 대칭 키 암호의 기본 개념
  - Kerchoff의 원리
    - 암호체계의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되며
    - 키의 비밀을 지키는데 의존되어야 한다
  - 용어 설명
    - 평문(Plaintext): 송신자가 수신자에게 보내는 본래의 메시지
    - 암호 알고리즘(Encryption algorithm): 평문을 암호문으로 변경하는 알고리즘
    - 복호 알고리즘(Decryption algorithm): 암호문을 평문으로 복원하는 알고리즘
    - 공유 비밀 키(Shared secret key): 송신자와 수신자가 함께 공유하는 암호화와 복호화에 사용되는 값
    - 암호(Cipher): 암호 알고리즘과 복호 알고리즘을 통칭 
  - 대칭 키 암호체계의 특징
    - 송신자와 수신자가 비밀 키를 공유함 즉, 암호 키와 복호 키가 동일 
    - ![image](https://user-images.githubusercontent.com/61530368/172433820-e3f5f460-3ed6-4160-9799-ffa0d259e8bc.png)
  - 고전 대칭 키 암호체계의 종류
    - 대치 암호: 평문(암호문)내 각 기호를 다른 기호로 치환하여 암호(복호화) 수행
    - 전치 암호: 평문(암호문)내 각 기호의 위치를 다른 위치로 변환하여 암호화(복호화) 수행   
## 3.2 대치 암호
  - 대치 암호란?
    - 하나의 기호를 다른 기호로 대체하여 암호화/복호화 수행
    - 대치암호는 단일문자암호, 다중문자 암호로 분류 
    - 단일 문자 암호
      - 평문에서 하나의 문자(기호)가 위치에 상관없이 암호문에서 항상 같은 문자(기호)로 대체
      - 항상 일대일 대응 관계를 갖는 암호체계 
## 3.2 전치 암호
## 3.4 스트림 암호와 블록 암호

# 4 암호 공격의 기본 개념
## 4.1 암호 공격의 개념
  - 암호 공격
    - 송신자와 수신자 이외의 허가 받지 않은 제3자가 암호 시스템을 공격하여 공개되지 않은 키를 불법적으로 회득하거나, 이를 이용하여 암호문의 내용을 가로채는 행위
    ![image](https://user-images.githubusercontent.com/61530368/172436471-0ae167fa-830e-4823-adee-66d6e5278aa3.png)
  - 수동적 공격
    - 메시지의 도청: 공격자가 전송되는 메시지를 도중에 가로채어 그 내용을 외부로 노출시키는 공격, 메시지의 내용을 공격하는 개념
  - 트래픽 분석
    - 존송 메시지의 암호화로 도청을 통한 메시지 내용 파악이 불가능한 경우, 송신자와 수신자의 메시지 전송 트래픽을 분석하여 암호문의 내용을 가로채어 해독하거나 이를 공개하는 개념
  - 능동적 공격
    - 메시지 변조: 전송되는 메시지 순서바꿈, 일부분을 다른 멧지ㅣ로 대체하여 불법적인 효과 발생
    - 삽입 공격: 공격자가 정당한 송신자로 가장 특정 수신자에게 메시지를 보내어 불법적인 효과를 발생
    - 삭제 공격: 정상적인 통신 시설의 사용과 관리를 방해하는 서비스 거부 등을 통해, 특정 수신자에게 전송되는 메시지의 전부 또는 일부를 삭제하는 공격
    - 재생 공격: 공격자가 이전에 특정 송신자와 수신자 간에 행해졌던 통화내용을 도청하여 보관 나중에 재생하여 전송하는 공격 
  - 암호 공격 방식
    - 암호문 단독 공격: 공격자는 단지 암호문만 갖고 있음 이로부터 평문 또는 키를 찾음
    - 기지 평문 공격: 공격자는 일정량의 평문에 대응하는 암호문을 알고 있는 상태에서 암호문의 내용을 해독하는 방법
    - 선택 평문 공격: 공격자가 암호 시스템에 접근하여 평문을 선택, 해당 평문에 해당하는 암호문을 회득한 후, 키 또는 평문을 추정하여 암호문의 내용을 해독
    - 선택 암호문 공격: 공격자가 암호 복호기에 접근하여 암호문에 대한 평문을 회득하여 암호를 해독
  - 암호 시스템의 안전성
    - 계산적 안전성: 암호 시스템을 공격하기 위해 필요한 계산량이 매우 많아서 현실적으로 공격할 수 없는 경우
    - 증명 가능한 안전성: 암호 시스템에서 사용중인 암/복호화 알고리즘이 어렵다고 알려진 문제와 등가라서 현실적으로 해결(공격)할 수 업슨ㄴ 경우
    - 절대적 안전성: 무한한 계산능력을 보유하고 있어도 암호 시스템을 공격할 수 없는 경우(= 무조건적 안전성)
  - 암호 알고리즘 개발자의 목표
    - 암호 해독 비용이 암호화된 정보의 가치를 초과할 수 있는 알고리즘 개발
    - 암호 해독 시간이 암호화된 정보의 유효 기간을 초과할 수 있는 알고리즘    
## 4.2 암호 공격 방법
  - 전수조사 공격 
    - 공격자는 키의 집합을 미리 알고 있다고 가정
    - 모든 가능한 키를 사용 암호문을 복호화하며, 의미 있는 평문이 도출 될 때 까지 이를 반복
  - 통계적인 공격(Statistical attack)
    - 공격자가 평문 언어의 고유한 특징으로부터 정보를 얻음
    - 예를 들어, 평문이 영어일 때 공격자는 암호문에서 가장 빈번하게 사용  
  - 패턴 공격
    - 평문 언어의 특징은 드러나지 않지만 암호문에 어떤 패턴이 존재할 경우, 이를 분석하여 키 유추
  - 암호문 단독 공격
    - 공격자는 암호문 C만을 갖고 있는 상황
    - 공격자가 암호문 C로부터 평문 P또는 키 K를 찾아내는 방법
    - ![image](https://user-images.githubusercontent.com/61530368/172549206-c365ab46-7783-4b51-b4c4-73b4fcfffdc0.png)
  - 기지 평문 공격 (Known plain text attack)
    - 기지 평문 공격(=알려진 평문 공격)은 공격자가 평문과 암호문을 모두 알고 있을 때 사용할 수 있는 암호 해독 기법
    - 즉, 공격자는 일정량의 평문 P에 대응하는 암호문 C를 알고 있을 때
    - 이 때, 공격자는 암호문 C와 평문 P의 관계로부터 키 K나 복호화 알고리즘을 추정 가능
    - 따라서, 기지 평문 공격의 최종 목표는 복호키를 찾는 것
    - ![image](https://user-images.githubusercontent.com/61530368/172549632-3953cdf3-0e70-40d9-9d80-5362f4dcb8f4.png)
  - 선택 평문 공격
    - 공격자가 많은 수의 평문을 암호문으로 만들 수 있는 상태(단, 암호 알고리즘이나 키에 대한 정보는 모르는 상태)에서 공격하는 유형
    -  ![image](https://user-images.githubusercontent.com/61530368/172549834-c57577aa-4297-43d6-bbe0-d137c344c8a8.png)

  - 선택 암호문 공격
    - 공격자가 임의로 선택된 암호문과 일치하는 평문으로부터 암호키를 알아내기 위해 시도하는 공격
    - 공격자가 많은 수의 암호문에 대한 평문을 확보한 상태에서 시도하는 공격 유형
    - ![image](https://user-images.githubusercontent.com/61530368/172550087-748e72d9-0da0-466d-8073-3ffe8f793e6e.png)  
## 4.3 고전 암호의 공격 방법
  - 단일치환 암호의 공격
  - Vigenere 암호의 공격
  - Hill Climbing Method
# 5 현대 블록 암호 
## 5.1 현대 블록 암호의 특징
  - 연산의 단위: 비트 단위로 수행
    - 한번에 n비트 평문 블록을 암호화/복호화
    - 평문이 n비트보다 크면 분할, 작으면 n비트가 되도록 패딩(덧붙이기)
    - 보통 n = 64, 128, 256, 512비트 등
    - 암호/복호 알고리즘은 동일한 k비트 비밀키를 사용
    - 복호 알고리즘은 암호 알고리즘의 역함수 
  - 대치와 전치
    - 현대 암호 체계는 대치(Substitution) 암호와 전치(Transposition)암호를 조합하여 동작하도록 설계
    - 특히, 현대 블록 암호는 전수조사 공격에 안전하기 위하여 대치 암호를 사용하여 설계
      - 전치 암호로만 설계하면 평문과 암호문에서 0과 1의 개수가 동일
      
## 5.2 Simplified-Data Encryption Standard (S-DES)
  - DES 개요
    - IBM에서 Lucifer System을 개선하여 개발
    - 특징
      - 64비트 블럭 암호 알고리즘
      - 56비트 키를 사용: 64비트 중 8비트는 parity check로 사용
      - 라운드 수: 16 라운드
      - 복호화는 암호화의 역순
  - S-DES
    - 개요   
      - Simplified-DES의 약자ㄹ
      - 교육용 알고리즘
      - 8비트 평문 블럭과 10비트 키를 사용
      - ![image](https://user-images.githubusercontent.com/61530368/172553263-36f0e527-83cb-454d-83e3-e5800a72ca23.png)
      - IP(initial Permutation): 초기 순열
      - 함수 fk: 각 비트별로 전치(transposition)와 치환(substitution) 연산 수행
      - SW: 각 데이터의 절반을 상호 교환하는 함수
      - IP^-1(Inverse Initial Permutation): 초기 순열의 역순인 순열 함수  
  - 암호화 과정
    - Ciphertext = IP^-1(fk2(SW(fk1(IP(Plaintext)))))
  - 복호화 과정
    - Plain = IP^-1(fk1(SW(fk2(IP(Ciphertext)))))
  - 키 생성 
    - S-DES는 10-bit Key를 사용, sub-key로써 두 개의 8-bit sub key
    - ex) P10 (1010000010) -> (1000001100)
    - ![image](https://user-images.githubusercontent.com/61530368/172554665-3a2eefc6-f6e2-482b-b1b1-61eb294aad99.png)
  - LS-1
    -  1비트 Circular Left Shift연산 : ex) 10001 -> 00011
  - 함수 fk
    - 전치와 치환연산 수행
    -   ![image](https://user-images.githubusercontent.com/61530368/172555684-aacfe83b-580d-4c7b-b99e-a8966c3347dd.png)
  - S-DES 분석
    - 전수조사(Brute force) 공격 가능
      - 10비트 키로 단지 2^10가지의 가능성이 존재하므로 전수조사 공격이 충분히 가능  

## 5.3 현대 블록 암호의 구성 요소
  - 현대 블록암호의 주요 구성 요소
    - 전치요소 (P-Box)
    - 대치요소 (S-Box)
    - 그 밖의 구성 요소들(XOR, Shift, Swap 등)
    - 위 3개를 결합하여 설계
  - P-Box
    - 문자 단위로 수행하였던 고전 전치 암호를 비트 단위로 수행
    - 세 종류의 P-Box가 존재
      - 단순(Straight) P-Box
      - 확장(Expansion) P-Box
      - 축소(Compression) P-Box
  - 단순 P-Box
    - n비트 길이의 워드를 입력 받아 n비트 길이의 출력하는 치환(permutation)함수
    - ![image](https://user-images.githubusercontent.com/61530368/172556596-0be89cf9-b6ca-443e-92dd-f97e004959ef.png)

  - 축소 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이의 워드(n > m)를 출력하는 P-Box
    - ![image](https://user-images.githubusercontent.com/61530368/172556739-099561c7-63d0-4978-815d-019175e8e943.png)
  - 확장 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이(n < m)의 워드로 출력하는 P-Box  
    - ![image](https://user-images.githubusercontent.com/61530368/172556907-ecb2879d-9fd9-4660-b1c2-618e0001296c.png)
  - P-Box의 역함수 존재성
    - 단순 P-Box는 입력 워드와 출력 워드의 비트간의 관계가 일대일 대응이므로 역함수 존재
    - 그러나, 축소 P-Box와 확장 P-Box는 일대일 대응이 아니므로 역함수가 존재하지 않음
  - S-Box
    - S-Box는 대치 암호를 나타냄
    - S-Box는 입력과 출력의 개수가 달라도 됨
    - S-Box는 m*n 대치 단위로 정의되며, 이 때 m과 n이 반드시 같을 필요는 없음  
    - ![image](https://user-images.githubusercontent.com/61530368/172557563-6ba60ddb-b10c-465a-9ad7-6847d8d41e74.png)

## 5.4 합성 암호
  - 합성 암호란?
    - 대치, 치환, 그리고 기타의 구성요소들을 결합한 복합적인 암호 
    - 설계된 블록암호가 혼돈과 확산의 성질을 갖도록 함
  - 혼돈과 확산 
    - 혼돈 
      - 암호문과 키의 관계를 숨김
      - 암호문을 이용하여 키를 찾고자 하는 공격을 어렵게 하기 위해 키의 단일 비트가 변하면 암호문의 거의 모든 비트들이 변하게 함
      - 즉, 암호문에 키를 알아내기 어렵게 하는 성질
    - 확산
      - 암호문과 평문 사이의 관계를 숨김
      - 통계 테스트를 사용하여 암호문에 대한 평문을 찾는 공격을 어렵게 함      
      - 즉, 암호문에서 원본 메시지를 알아내기 어렵게 하는 성질
  - 라운드 (Rounds)
    - 혼돈과 확산은 S-Box와 P-Box 그리고 기타 구성 요소들을 결합하는 합성 암호를 반복적으로 사용하여 구현
    - 이 때, 반복적으로 사용되는 합성 암호를 '라운드'라 함
    - 아래는 두 라운드로 구성된 합성 암호 다이어그램
    -  ![image](https://user-images.githubusercontent.com/61530368/172861442-d5e07e42-ece0-4cca-81b6-b391b46ca68f.png)
  - 현대 암호시스템의 구성 방법
    - 실제 암호시스템에서는 혼돈과 확산의 효과를 그대화하기 위하여 더 큰 데이터 블록과 더 많은 S-Box 그리고 더 많은 라운드를 사용
    - 암호문을 더욱 난수처럼(= 유사난수) 생성되게 함
    - 암호문과 평문 사이의 관계를 더욱 알아내기 힘들게 함(확산)
    - 라운드 수의 증가는 라운드 키의 개수를 증가시킴으로써 암호문과 키의 관계를 유추하기 어렵게 함(혼돈)
  - 두 종류의 합성 암호
    - Feistel 암호: 역함수가 존재하는 구성요소와 역함수가 존재하지 않는 구성요소 모두를 사용하여 설계
      - ex) DES 
    - Non-Feistel 암호: 역함수가 존재하는 구성요소만을 사용하여 설계   
      - ex) AES
  - Feistel 암호
    - Feistel 암호 구성요소 
      - 자기 자신을 역으로 갖는 것
      - 역함수가 존재하는 것
      - 역함수가 존재하지 않는 것
      - 역이 존재하지 않은 구성요소들을 서로 결합하고, 암호 알고리즘과 복호 알고리즘에서 동일한 구성요소를 사용
    - Feistel 암호의 초기 구조
      - ![image](https://user-images.githubusercontent.com/61530368/172863074-2a2d9741-a913-42ef-bfb9-38d726fadb21.png)
      - 암호화: C1 = P1 XOR f(K)
      - 복호화: P2 = C2 XOR f(K) = P1 XOR f(K) XOR f(K) = P1  
      - Feistel 구조에서 믹서는 자기 자신을 역함수로 갖음
    - 초기 구조에 대한 향상
      - ![image](https://user-images.githubusercontent.com/61530368/172863418-5d73a0bb-4dbd-4c13-bb01-52f98423281b.png)
      - 함수의 입력을 키와 평문으로 복합적으로 구성하기 위해 평문을 두 부분으로 나눔
      - 또한, 암호 알고리즘과 복호 알고리즘은 여전히 서로 역관계
  - Non-Feistel 암호
    - 주요 특징
      - S-Box는 적절하게 동일한 입출력 개수를 가져야 함
      - 축소 혹은 확장 P-Box는 역함수가 존재하지 않기 때문에 사용 할 수 없음
      - 평문이 반씩 분할될 필요 없음
      - XOR, 역이 존재하는 2 X 2 S-Box, 역이 존재하는 단순 P-Box만을 구성요소로 이용
      - 복호화에는 라운드 키를 역순으로 이용    

# 6 블록 암호에 대한 공격 방법 
## 6.1 블록 암호에 대한 공격 방법
  - 블록 암호에 대한 공격 방법
    - 차분 분석
    - 선형 분석
  - 차분 분석
    - 알고리즘 분석
      - 먼저 암호 알고리즘을 분석
      - 특정 암호는 공격자가 키를 알지 못해도 평문의 차분과 암호문의 차분 사이의 관계를 찾을 수 있는 구조적 취약점을 갖음
    - 선택 평문 공격의 시작
      - 공격자는 공격을 위해 필요한 평문의 차분을 선택   
    - 키 값의 추축
      - 공격자는 키 값을 추측하기 위하여 선택한 특정 평문과 암호문 쌍을 찾음
  - 선형 암호분석
    - 기지 평문 공격(= 알려진 평문 공격)을 이용 
## 6.2 현대 스트림 암호  
  - 현대 스트림 암호 개요
    - 암호화와 복호화 과정에서, r비트를 생성
    - 평문 비트 스트림 P = pn ... p2 p1 -> 암호화: ci = E(ki, pi) 
    - 암호 비트 스트림 C = cn ... c2 c1 -> 복호화: pi = D(ki, ci)
    - 키 비트 스트림 K = kn ... k2 k1
    -![image](https://user-images.githubusercontent.com/61530368/172867464-411b075d-aa43-4c86-9730-5b9e365b75ca.png)
  - 현대 스트림 암호의 특징
    - 블록 암호보다 속도가 빠름
    - 하드웨어 구현이 블록 암호보다 용이
    - 이진 스트림 단위의 암호화가 필요하고 고정된 속도로 암호화된 데이터를 전송하고자 할 때 스트림 암호가 적합함
    - 전송 도중 비트의 변조에 강인함
    - 현대 스트림 암호에서는 키 스트림 K = kn ... k2 k1를 어떻게 생성하는지가 주된 관심분야
  - 현대 스트림 암호의 종류
    - 동기식 스트림 암호(Synchronous Stream Ciphers)
  - 비동기식 스트림 암호(Nonsynchronous Stream Ciphers)
    - 키 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정됨
  - 동기식 스트림 암호
    - 키 스트림은 평문 혹은 암호문과 독립
    - 즉, 키는 평문/암호문과 어떤 관계도 없이 생성되고 사용됨
    - 동기식 스트림 암호의 종류
      - 일회용 키패드
      - 귀환 이동 레지스터
  - 일회용 패드(One - time pad)
    - 가장 간단하고 안전한 동기식 스트림 암호
    - 그러나 실제적으로 사용되기에는 매우 어려움 
      - 송신자가 수신자에게 키 스트림을 전달할 수 있는 안전한 채널이 존재해야 하므로, 현실적으로 구현이 불가능
      - ![image](https://user-images.githubusercontent.com/61530368/172868322-46dcf0af-1ca6-4ae4-b99e-c6b9d89490c1.png)
  - 비동기식 스트림 암호
    - 비동기식 스트림 암호에서 키 스트림의 각 비트는 이전의 평문이나 암호문에 종속되어 결정됨   
# 7 비대칭 키 암호의 기본 개념
## 7.1 소수와 나머지 정리 요약
  - 양의 정수의 3가지 종류:1, 소수, 합성수
    - 자기 자신만을 소수로 약수로 갖는 수 -> 1
    - 1과 자기 자신만을 약수로 갖는 수 -> 소수 (Primes)
    - 3개 이상의 약수를 갖는 수 -> 합성수 (Composites)
  - 서로소
    - 두 정수 a, b에 대하여 1이외에 공약수가 존재하지 않는 경우 
  - 소인수분해
    - 1보다 큰 자연수를 소인수(=소인수 인수)들만의 곱으로 나타내는 것 

## 7.2 비대칭 키 암호 시스템 특징
  - 비대칭 키 암호시스템에서는 두 개의 서로 다른 키를 사용
    - 공개키: 누구에게나 공개가 가능한 키
    - 비밀키: 자신만이 갖고 있는 키
  - 공개키로 암호화하는 경우
    - 송신자가 공개키로 평문을 암호화한 후 수신자에게 전송
    - 수신자는 자신이 갖고 있는 개인키를 이용하여 수신된 암호문을 복호화
    - ex) 공개키 암호 알고리즘 (RSA, Rabin...)
    - ![image](https://user-images.githubusercontent.com/61530368/172885867-98aa51d0-ac48-4d00-9d17-6ac30b712660.png)

  - 개인키로 암호화하는 경우
    - 송신자는 자신이 갖고 있는 개인키를 활용하여 평문을 암호화
    - 수신자에게 공개키와 함께 전달 
    - 이때, 수신자는 공개키를 이용하여 암호문을 복호화
    - 이 방법은 데이터의 보안보다는 데이터를 전송하는 송신자의 신원을 보장하는 데 더 큰 의의가 있음
      - 암문을 공개키로 복호화 -> 공개키와 쌍을 이루는 비밀키로 암호화되어었음을 의미 -> 이 비밀키는 오직 송신자만 갖고 있는 것 -> 송신자의 신원이 확실하게 보장됨을 의미
    - ex) 전자 서명    
    - ![image](https://user-images.githubusercontent.com/61530368/172885915-6b5a290a-6952-4183-8db0-9482350bc2c3.png)
  - 비대칭키 암호의 일반적인 아이디어 
    - ![image](https://user-images.githubusercontent.com/61530368/172886046-0baff05b-a951-49bf-9c43-d44c48206cea.png)
    - 대칭 키 암호시스템과는 다르게, 비대칭 키 암호시스템에서는 평문이나 암호문이 정수로 다뤄짐
  - 트랩도어 일방향 함수(Trapdoor One-Way Function)
    - 비대칭 키 암호시스템을 구성하는 핵심 아이디어 중 하나
    - 일방향 함수(One-Way Function (OWF))
      - 함수 f는 계산이 쉬운 반면에, 역함수 f^-1d는 계산이 어렵다 
      - ![image](https://user-images.githubusercontent.com/61530368/172886918-91fad376-f7a3-408e-af4f-50dce6b55ca4.png)

    - 트랩도어 일방향 함수란 ?
      - 보통 일방향함수처럼 함수의 역을 구하는 것은 어렵지만, 트랩도어라고 부르는 특수한 비밀정보가 있으면 쉽게 역을 구할 수 있는 함수
      - 어떤 비밀 값 t에 대해서, x에 대한 t가 없을 때는 f로부터 x를 구하기 어렵지만, t가 주어졌을 때 f에서 x값을 쉽게 찾을 수 있다면, 함수 f는 트랩도어 함수이다
      - ![image](https://user-images.githubusercontent.com/61530368/172887435-318e07cf-c040-4c15-8b8a-5ec90a3d0f0d.png)
      - ex1) n이 매우 큰 수라고 가정. 이 경우, n = p * q는 일방향 함수. 이때, 주어진 p와 q로부터 n을 계산하는 것은 매우 쉽다. 하지만 주어진 n으로부터 p와 q를 계산하는 것은 매우 어렵다 -> 소인수분해 문제 
      - ex2) n이 매우 큰 수라면, 함수 y = xk mod n은 트랩도어 일방향 함수임. 이 때, x,k,n으로부터 y를 계산하는 것은 쉬움. 하지만 y,k,n이 주어졌을 때, x를 계산하는 것은 매우 어려움 -> 이산대수 문제  

## 7.3 배낭 암호
  - 최초의 공개 키 암호 시스템 아이디어
  - 현재 사용하는 공개키 암호 시스템을 구성하는 아이디어의 토대
  - 배낭 암호의 기본 원리
    - 사전에 정해진 수의 집합에서 선택된 임의의 원소들 중 어떤 것들이 배낭속에 들어있는지를 알려준다면 우리는 이 수들의 합을 쉽게 계산할 수 있음
    - 그러나, 합의 결과만 알고 있는 경우에는 그 배낭속에 들어 있는 수들이 무엇인지 알아내기는 것은 어려움 
  - 2개의 k-순서짝 a = [a1, ..., ak]와, x = [x1, ..., xk]가 주어졌을 때, 배낭 암호는 다음과 같이 정의
    - s = knapsackSum(a,x) = x1a1 + x2a2 + ... + xk*ak
    - 주어진 a와 x로부터 s를 계산하는 것은 이지 
    - but s와 a가 주어졌을 때, x를 구하는 것은 하드
    - 즉, s = kanpsackSum(a, x)는 쉽게 계산할 수 있지만, x = inv_knapsackSum(s, a)을 계산하는 것은 하드
    - 함수 knapsackSum(a, x)은 a가 일반적인 k-순서짝일 경우 하나의 일방향 함수이다 
  - 초증가 순서짝(Superincreasing Tuple)
    - a의 첫번째 원소 a1를 제외한 임의의 원소 ai가 ai >= a1 + a2 + ... + ai-1를 만족한다면, a는 "초증가 순서짝"이다 
    - 즉, 집합 a의 원소 a1을 제외한 각각의 원소가 그 이전의 모든 원소의 합보다 크거나 같은 경우
  - 초증가 순서쌍에 대한 배낭 알고리즘과 역 알고리즘
    - ![image](https://user-images.githubusercontent.com/61530368/173092828-94169e55-5abb-481a-905e-9ab30aa19a3b.png)
  - 배낭을 이용한 비밀 통신
    - ![image](https://user-images.githubusercontent.com/61530368/173092930-2f47d232-27a8-4f33-924f-b16596340586.png)
    - 키 생성 (Key generation)
      - 초증가 k-순서짝 b = [b1, ... bk]를 만든다
      - n > b1 + b2 + ... + bk를 만족하는 모듈로 n을 선정
      - n하고 서로소이면서 1 <= r <= n-1인 임의의 정수 r을 선택
      - ti = r*bi mod n을 만족하는 임시 k-순서짝 t = [t1, t2, ..., tk]를 생성
      - k개의 원소에 대한 한 가지 치환을 하여 새로운 순서짝 a = permute(t)를 구함
      - k-순서짝 a를 공개 키로 사용하고, n, r, k-순서짝 b를 개인 키로 사용
      - ![image](https://user-images.githubusercontent.com/61530368/173094390-24d0f6e0-8a0b-4014-be3a-2e214b61c4d8.png)

    - 암호화(Encryption)
      - 송신자는 자신의 메시지를 k-순서짝 x = [x1, x2, ..., xk]로 변환시킨다.(여기서 xi는 0이거나 1이다. 순서짝 x는 평문)
      - 송신자는 knapsackSum 알고리즘을 사용해서 s계산
      - 그다음, 암호문 s를 수신자에게 보냄 
      - ![image](https://user-images.githubusercontent.com/61530368/173094421-28035b11-1c39-4c3e-a96f-a1dede298844.png)

    - 복호화(Decryption)
      - 수신자는 s' = r^-1 * s mod n을 계산
      - 수신자는 inv_knapsackSum을 사용하여 x'을 계산
      - x'을 치환하여 x를 구함. 순서짝 x는 복호화된 평문
      - ![image](https://user-images.githubusercontent.com/61530368/173094570-d32f080f-0124-4f52-8b24-816184fe9cf3.png)
    - 트랩도어(1/2)
      - 송신자의 배낭에 들어있는 원소의 합을 계산하는 것은 것이 궁극적으로는 행벡터 x와 열 벡터 a와의 행렬 곱
      - 그 결과는 1x1 행렬인 s 
      - 행 벡터 x와 열 벡터 a와의 행렬 곱인 s = x * a는 일방향 함수
      - 주어진 s와 x로부터 공격자는 a를 쉽게 구할 수 없다
    - 트랩도어(2/2)
      - 한편, 수신자는 트랩도어를 가지고 있다
      - 즉, 수신자는 자신의 s' = r^-1 * s와 비밀 초증가 열 벡터인 b를 inv_knapsackSum에 입력하여 행 벡터인 x'를 구할 수 있다
      - 결과적으로, 치환을 하게 되면 수신자는 x'으로부터 x를 구할 수 있다
  - 배낭을 이용한 통신 예제 (시험에 나옴)
    - 키생성
      - 수신자는 초증가 순서짝 b = [7, 11, 19, 39, 79, 157, 313]을 만든다
      - 수신자는 모듈로로 n = 900, r = 37을 선택 (치환표로는 [4 2 5 3 1 7 6]을 선택)
      - 수신자는 순서짝 a = permute(t) = [543, 407, 223, 703, 259, 409]을 계산
      - 수신자는 순서짝 t = [259, 407, 703, 259, 781, 409]를 계산
      - 수신자는 a를 공개. 그리고 n, r, b는 비밀로 한다
    - 송신자가 단 하나의 문자 "g"만을 수시낮에게 보낸다고 가정 
      - 송신자는 7비트 ASCII코드를 이용하여 "g"를 (1100111)2로 부호화
      - 그 다음 순서짝 x = [1, 1, 0, 1, 1, 1]을 생성. 이것이 평문
      - 송신자는 s=knapsackSum(a, x) = 2165를 생성. 이것이 수신자에게 보낼 암호문
    - 수신자는 암호문 s = 2165를 복호화
      - 수신자는 s' = x * r^-1 mod n = 2165 * 37^-1 mod 900 = 527을 계산
      - 수신자는 x' = inv_knapsackSum(a', b) = [1, 1, 0, 1, 0, 1, 1]를 계산
      - 수신자는 x = permute(x') = [1, 1, 0, 0, 1, ,1 , 1]을 계산하여 (1100111)2를 얻음
      - 이것을 ASCII 코드를 이용하여 문자로 환원하면 문자 "g"를 얻음 
## 7.4 RSA 암호시스템
  - 개요
    - RSA: 개발자 3명의 이름을 따서 만듦
    - 가장 많이 사용되는 공개 키 알고리즘
    - RSA는 모듈로 지수연산을 이용하여 암호화/복호화를 한다
    - 이것을 공격하려면 공격자는 C^(1/e) mod n을 계산해야한다(지수 복잡도이며 공격이 매우 하드)
    - ![image](https://user-images.githubusercontent.com/61530368/173098854-dbd91c66-b42c-427f-9742-956179db7141.png)
  - 키 생성
    - 군 G에서 공개키와 비밀키를 생성
    - ![image](https://user-images.githubusercontent.com/61530368/173100098-6b8f8663-f8f1-4ba7-b84b-85af4861d462.png)
    - 수신자는 순서쌍(e, n)을 공개키로, d를 비밀키로 설정
    - p, q와 O(n)을 버림 
    - 이 때, 안전을 위해 권장되는 p와 q의 크기는 512비트

  - 암호화
    - 환 R에서 공개키 (e, n)을 사용하여 평문을 암호화
    - C ≡ P^e mod n 
    - where (e,n):공개키
    - ![image](https://user-images.githubusercontent.com/61530368/173100273-ee4bd4a6-c11e-4038-b882-c98a736e5eb3.png)
    - 공개키 (e, n)을 사용하여 수신자에게 메시지를 보낼 수 있음
    - 다항식 연산 정도의 복잡도를 가진 알고리즘을 이용해서 수행
    - 평문의 크기는 n의 길이보다 작아야 하며, 만약 평문 길이가 n보다 크다면, 평문을 n보다 작은 블록으로 나누어 암호화함
   

  - 복호화
    - 환 R에서 비밀키 d를 이용하여 암호문을 복호화   
    - P ≡ C^d mod n
    - where d: 비밀키
    - ![image](https://user-images.githubusercontent.com/61530368/173100449-dcee1990-1e68-49df-ae66-b78f5c402d3f.png)
    - 암호화와 마찬가지로 다항식 연산 정도의 복잡도로 계산
    - 이 때 암호문의 크기는 n보다 작음
- RSA 암호화/복호화 예제
  - 수신자는 p와 q를 7과 11로 선택해서 n = 7*11 = 77을 계산
  - 그렇다면 O(n) = (7 - 1) * (11 -1) = 60
  - 수신자는 Z^(*)60내에서 두 개의 지수 e와 d를 선택
  - 이 때, 만약 e = 13이면 d = 37이 된다(e * d mod 60 = 1)
  - ![image](https://user-images.githubusercontent.com/61530368/173101255-85e5039b-13df-4f45-b5fb-1b6761a13b22.png)
  - 이제 송신자가 평문 5를 수신자에게 보낸다고 가정
  - 이 경우, 송신자는 공개된 값 e = 13을 이용해서 5를 다음과 같이 암호화
    - 평문: 5, C = 5^13 mod 77 = 26
  - 수신자는 암호문 26을 수신하게 되며 자신의 개인키 d = 37을 이용하여 이 암호문을 다음과 같이 복호화
    - 암호문: 26, P = 26^37 mod 77   

## 7.5 Rabiin 암호시스템 
  - 개요
    - Rabin 암호시스템은 e와 d가 고정된 값을 갖는 RSA 암호시스템
      - e = 2, d = 1/2
      - 암호화 C ≡ P^2 mod n
      - 복호화 P ≡ C^(1/2) mod n
    - 
    - ![image](https://user-images.githubusercontent.com/61530368/173101987-649d73c1-ad63-4e3a-b265-c6a5f82361b8.png)



