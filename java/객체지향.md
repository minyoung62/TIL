# 객체지향 언어 1
  ## 1. 객체지향 언어
  ### 1.1 객체지향언어의 역사
  ### 1.2 객체지향언어
  - 특징
    - 코드의 재사용성이 높음
    - 코드의 관리가 용이
    - 신뢰성이 높은 프로그래밍을 가능
  ## 2. 클래스와 객체
  ### 2.1 클래스와 객체의 정의와 용도
  - 클래스의 정의
    - 클래스란 객체를 정의해 놓은 것이다
  - 클래스의 용도
    - 클래스는 객체를 생성하는데 사용된다
  - 객체의 정의
    - 실제로 존재하는 것. 사물 또는 개념
  - 객체의 용도
    - 객체가 가지고 있는 기능과 속성에 따라 다름
  - 유형의 객체
    - 책상, 의자, 자동차, TV와 같은 사물
  - 무형의 객체
    - 수학공식, 프로그램 에러와 같은 논리나 개념
 ### 2.2 객체와 인스턴스
  - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함
 ### 2.3 객체의 구성요소 - 속성과 기능
  - 속성 : 멤버변수, 특성, 필드, 상태
  - 기능 : 메서드, 행위, 함수
 ### 2.4 인스턴스의 생성과 사용
  - p 123참고
 ### 2.5 클래스의 또 다른 정의
  - 변수 : 하나의 데이터를 저장할 수 있는 공간
  - 배열 : 같은 종류의 여러 데이터를 하나의 집한으로 저장할 수 있는 공간
  - 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
  - 클래스 : 데이터와 함수의 결합
## 3. 변수와 메서드
 ### 3.1 선언위치에 따른 변수의 종류
  - 클래스 영억 
    - 인스턴스 변수 : 인스턴스가 생성될 때 생성됨
    - 클래스변수(static 변수, 공유변수) : 클래스가 메모리에 올라갈 때 생성됨
  - 메서드영역
    - 지역변수 :변수 선언문이 수행되었을때 생성됨
### 3.2 클래스변수와 인스턴스변수
   - 인스턴스변수 
    -인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지
   - 클래스 변수
    - 모든 인스턴스가 하나의 저장곤간을 공유, 항상 공통된 값을 가짐
### 3.3 메서드
  - 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다
  - 반복적으로 수행되어야 하는 여러 문장을 하나의 메서드로 정의해 놓으면 좋다
  - 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다
### 3.4 return문
### 3.5 메서드의 호출 
### 3.6 JVM의 메모리구조
  - 메서드영역(metohd area)
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어 분석
    - 클래스에 대한 정보(클래스 데이터)를 메서드 영역에 저장. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성  
  - 힙(heap)
    - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성
    - 즉, 인스턴스 변수들이 생성되는 공간
  - 호출스택(call stack 또는 execution stack) 
    - 메서드의 작업에 필요한 메모리 공간을 제공
    - 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당
    - 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
    - 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐
### 3.7 기본형 매개변수와 참조형 매개변수
  - 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다
  - 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다
### 3.8 재귀호출(recursive call)
### 3.9 클래스메서드(static메서드)와 인스턴스 메서드
  - 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙임
  - 클래스변수(static메서드)는 인스턴스를 생성하지 않아도 사용할 수 있다
  - 클래스변수(static변수)는 인스턴스변수를 사용할 수 없다
  - 메서드 내에서 인스턴스변수를 사용하지 않는다면, static을 붙이는 것을 고려한다
    - 메서드 호출시간이 짧아지기 때문에 효율이 높아진다 
    - static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요 
    - 때문에 인스턴스메서드는 호출 시간이 더 오래걸림  
### 3.10 클래스멤버와 인스턴스멤버간의 참조와 호출
  - static메서드에서는 인스턴스 메서드 호출 불가
  - static메서드에서는 인스턴스 변수 사용 불가
  - 클래스변수는 인스턴스 변수를 사용할 수 없음
## 4 메서드 오버로딩
### 4.1 메서드 오버로딩이란?
  - 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
### 4.2 오버로딩의 조건
  - 메서드 이름이 같아야 한다
  - 매개변수의 개수 또는 타입이 달라야 한다
  - 매개변수는 같고 린턴타입이 다른 경우는 오버로딩이 성립되지 않는다
### 4.3 오버로딩의 예
### 4.4 오버로딩의 장점

## 5 생성자(Constructor)
### 5.1 생성자란?
  - 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
  - 생성자의 이름은 클래스의 이름과 같아야 한다
  - 생성자는 리턴 값이 없다
### 5.2  기본 생성자(default constructor)
  - 생성자 메서드가 하나도 없으면 컴파일러가 자동적으로 기본생성자를 추가해준다
  - 생성자가 있을 때 기본생성자는 생성되지 않는다
### 5.3 매개변수가 있는 생성자
### 5.4 생성자에서 다른 생성자 호출하기 - this(), this
  - 생성자 간에도 서로 호출이 가능 ( 아래의 조건 만족시 가능 )
    - 생성자의 이름으로 클래스이름 대신 this를 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능
  - this
    - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다
    - 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재
  - this(), this(매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 
### 5.5 생성자를 이용한 인스턴스의 복사
  ``` java
  Car(Car c) {
    color = c.color;
    gearType = c.gearType;
    door = c.door;
  }
  ```
## 6 변수의 초기화
### 6.1 변수의 초기화
  - 지역변수 초기화
    - 사용하기 전에 반드시 초기화 필요
  - 멤버변수 초기화
    - 명시적 초기화
    - 생성자
    - 초기화 블럭
      - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
      - 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용
### 6.2 명시적 초기화(explicit initialization)
  ``` java
  class Car {
    int door = 4;            // 기본형 변수의 초기화
    Engine e = new Engine(); // 참조형 변수의 초기화
  }
  ```

### 6.3 초기화 블럭(initialization block)
  - 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
    - 클래스 초기화 블럭은 크래릇가 메모리에 처음 로딩될 때 한번만 수행
  - 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용
    - 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행
  - ex
   ``` java
   class InitBlock {
    static { /* 클래스 초기화블럭 입니다 */}
    {/* 인스턴스 초기화블럭 입니다 */}
   }
   ```
 ### 6.4 멤버변수의 초기화 시기와 순서
  - 클래스변수의 초기화 시점
    - 클래스가 처음 로딩될 때 단 한번 초기화
  - 인스턴스변수의 초기화 시점
    - 인스턴스가 생성딜 때마다 각 인스턴스별로 초기화가 이루어짐
  - 클래스변수의 초기화순서
    - 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
  - 인스턴스변수의 초기화순서
    - 기본값 -> 명시적초기화 -> 인스턴스초기화 블럭 -> 생성자
# 객체지향 프로그래밍 2
  ## 1 상속(inheritance)
  ### 1.1 상속의 정의와 장점
  - 상속이란?
    - 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 장점
    - 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생상성과 유지보수에 크게 기여
  - 조상 클래스 : 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
  - 자손 클래스 : 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
  ### 1.2 클래스간의 관계 - 포함관계
  ``` java
  class Circle {
    Point c = new Point(); // 원점
    int r;
  }
  ```
  ### 1.3 클래스간의 관계 결정하기
  - '~은 ~이다(is-a)'와 '~은 ~을 가지고 있다(has-a)'를 넣어서 문장을 만들어 보면 클래스 간의 관계가 보다 명확해짐
  - ex) 2번째가 더 옳다는 것을 알 수 있음 
  ```
  1. 원(Circle)은 점(Point)이다 - Circle is a Point
  2. 원(Circle)은 점(Point)을 가지고 있다 - Circle has a Point
  ```
  - 상속관계 : is-a
  - 포함관계 : has-a
 ### 1.4 단일상속(single inheritance)
  - 자바는 단일 상속만 지원
  - 이유: 만약 다중 상속일 때 부모들이 같은 메서드를 가지고 있을 때 구별하기가 힘들다 때문에 자바는 단일 상속을 선택 (다중 상속을 지원하는 언어도 있음)
 ### 1.5 Object 클래스 - 모든 클래스의 조상
  - Object 클래스는 모든 클래스 상속계층도의 제일 위에 위치하는 조상 클래스
  - 모든 클래스들은 자동적으로 Object클래스로부터 상속을받게 함
  - toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있는 이유임
 ### 2 오버라이딩(overriding)
 ### 2.1 오버라이딩이란?
  - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 함
 ### 2.2 오버라이딩의 조건
  - 이름이 같아야 함
  - 매개변수가 같아야 함
  - 리턴타입이 같아야 함
  - 하지만, 접근 제어자 + 예외는 제한된 조건 하에서만 다르게 변경 가능
  - + 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가능 
  - + 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
 ### 2.3 오버로딩 VS 오버라이딩
  - 오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것
  - 오버라이딩 : 상속받은 메서드의 내용을 변경하는 것
 ### 2.4 super 
  - super란?
    - 자손 클래스에서 조장 클래스로부터 사옥받은 멤버를 참조하는데 사용되는 참조 변수
    - 조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super와 his는 근본적으로 같다
 ### 2.5 super() - 조상 클래스의 생성자
  - this()와 마찬가지로 super() 역시 생성자임
  - super()는 조상 클래스의 생성자를 호출하는데 사용
  - Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 조상의 생성자)를 호출해야함
  - 그렇지 않으면 컴파일러가 자동적으로 super();를 생성자의 첫 줄에 삽입
## package와 import
 ### 3.1 패키지(package)
  - 패키지란?
    - 클래스의 묶음
    - 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리 가능
 ### 3.2 패키지의 선언
  - 선언 방법
    - package 패키지명;
 ### 3.3 import문
  - 다른 패지키의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야함 
  - 매번 패키지명을 붙여주기 힘듦 
  - 그래서 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략 가능
  - 참고 ) import문은 프로그램의 선능에 전혀 영향을 미치지 않는다. import문을 많이 사용하면 컴파일 시간이 아주 조금 더 걸리 뿐이다
 ### 3.4 import문의 선언
  - 일반적인 스소프알(*.java)의 구성 순서
    - package문
    - import문
    - 클래스 선언
 ## 제어자(modifier)
 ### 4.1 제어자란?
  - 제어자란?
    - 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
  - 접근 제어자 
    - public, protected, dafualt, private
  - 그 외
    - static, final, abstract, native, transient, synchronized, volatile, stricftp
### 4.2 static - 클래스의, 공통적인
  - static
    - 클래스 변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다
    - 모든 인스턴스가 공유
  - static 멤버변수
    - 모든 인스턴스에 공통적으로 사용되는 클래스변수
    - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능
    - 클래스가 메모리에 로드될 때 생성
  - static 메서드
    - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드
    - static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없음
  - 참고
    - static초기화 블럭은 클래스가 메모리에 로드될 때 단 한번만 수행
    - 주로 클래스변수(static멤버변수)를 초기화하는데 주로 사용
### 4.3 final - 마지막의, 변경될 수 없는
  - final 클래스
    - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 됨
    - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음 
  - final 메서드
    - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없음 
  - final 멤버변수, 지역변수 
    - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 됨 
### 4.4 생성자를 이용한 final 멤버변수 초기화
  - final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에함
  - 하지만, 인스턴스변수의 경우 생성자에게 초기화 되도록 할 수 있음
### 4.5 abstract - 추상의, 미완성의
  - abstract
    - '미완성'의 의미를 가지고 있음
    -  메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용
  - abstract 클래스
    - 클래스 내에 추상메서드가 선언되어 있음을 의미
  - abstract 메서드
    - 선언부만 작성하고 구현부는 작성하지 않은 추상메서드임을 알림
### 4.6 접근 제어자(access modifier)
  - private
    - 같은 클래스 내에서만 접근이 가능   
  - default
    - 같은 패키지 내에서만 접근 가능   
  - protected
    - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능 
  - public 
    - 접근 제한이 전혀 없다
### 4.7 접근 제어자를 이용한 캡슐화
  - 접근 제어자 사용 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
 ### 4.8 생성자의 접근 제어
  - 생성자에 접근 제어
    - 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다
    ``` java
    class Singleton {
      private static Singleton s = new Singleton();
      private Singleton() {
        //..
      }
      pbulic static Singleton getInstance() {
      }
   
     }
    ```
### 4.9 제어자(modifier)의 조합
  - 메서드에 static과 abstract를 함께 사용할 수 없다
    - static메서드는 몸통이 있는 메서드에만 사용할 수 있기 때문  
  - 클래스에 abstract와 final을 동시에 사용할 수 없다
    - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미
    - 하지만, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 모순 
  - abstract메서드의 접근 제어자가 private일 수 없다
    - absract메서드는 자손클래스에서 구현해줘야 하는데,
    - 접근 제어자가 private이면, 자손 클래스에서 접근할 수 없음  
  - 메서드에 private과 final을 같이 사용할 필요는 없다
    - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문, 
    - 둘 중 하나만 사용해도 의미가 충분
## 5. 다형성(polymorphism)
 ### 5.1 다형성이란?
  - 다형성이란?
    - 여러 가지 형태를 가질 수 있는 능력
    - 조상 클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록하는 것 
  ``` java
  class Tv{
    boolean power;
    int channel;
    
    void power() {}
    void channelUp() {}
    void channelDown() {}
  }
  
  class CaptionTv extends Tv{
    String text;
    void caption() {}
  }
  ```
  - 아래 처럼 조상 클래스 타입의 참조변수로 자손 크랠스의 인스턴스를 참조하도록 하는 것이 가능
  - 그러나 CaptionTv에 있는 변수랑 메서드인 text, caption()은 사용 불가능
 ```
 CaptionTv c = new CaptionTv();
 Tv t = new CaptionTv();
 ```
  - 반대는 불가능(실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많이 때문)
 ```
 CaptionTv c = new Tv(); // 컴파일 에러 발생
 ```
  - 정리
    - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다
    - 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다
### 5.2 참조변수의 형변환
  - 자손타입 -> 조상타입 (Up-casting) : 형변환 생략가능
  - 자손타입 <- 조상타입 (Down-casting) : 형변환 생략불가능
  - 추가
    - 캐스트연산자를 사용하면 서로 상속관계에 있는 클래스 타입의 참조변수간의 형변환은 양뱡향으로 자유롭게 수행될 수 있따
    - 그러나, 참조변수가 참조하고 있는 인스턴스의 자손타입으로 형변환을 하는 것은 허용되지 않는다
### 5.3 instanceof연산자
  - instanceof 연산자
    - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위한 변수
    - instanceof를 이용한 연산결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것
    - 아래 코드는 instanceof 연산자로 Car타입의 참조변수 c가 FireEngine타입의 인스턴스를 참조하고 있는지 검사하고, 그 결과가 true이면, 형변환을 통해 FireEngine타입의 참조변수가 참조하도록 하여, FireEngine의 인스턴스의 멤버인 water()를 사용할 수  있또록 한것
 ``` java
 if (c instanceof FireEngine) {
  FireEngine fe = (FireEngine) c;
 }
 ```
  - 정리 
    - 어떤 타입에 대한 isntanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것
### 참조변수와 인스턴스의 연결
  - 멤버변수가 조상 클래스와 자손 클래스에 중복으로 정의된 경우
    - 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용됨
    - 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용됨 
### 매개변수의 다형성
  -  참조변수의 다형적인 특징을 메서드의 매개변수에 적용
    - 매개변수가 Product타입의 참조변수라는 것은, 메서드의 매개변수로 Product클래스의 자손타입의 참조변수면 어느 것이나 매개변수로 받아들일 수 있다는 것 
  ``` java
  class Product {
    int price;
    int bonusPoint;
  }
  class Tv extends Product {}
  class Computer extends Product {}
  class Audio extends Product {}
  
  class Buyer {
    int money = 1000;
    int bonusPoint = 0;
    void buy(Product p) {
      money = money - p.price;
      bonusPoint = bounsPoint + p.bonusPoint;
    }
  }
  ```
### 5.6 여러 종류의 객체를 하나의 배열로 다루기
  - 아래와 같이 조상타입의 참조변수로 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어 다룰 수 있다
  ``` java
  Product p[] = new Product[3];
  p[0] = new Tv();
  p[1] = new Computer();
  p[2] = new Audio();
  ```
## 추상클래스(abstract class)
### 6.1 추상클래스란?
  - 추상클래스란?
    - 미완성 설계도
    - 미완성 메서드(추상메서드)를 포함하고 있다는 의미 
### 6.2 추상메서드(abstract method)
  - 추상메서드
    - 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것
  - 사용 이유
    - 상속받은 클래스에 따라 달라질 수 있기 때문
  - 사용법
    - 아래와 같이 사용
    - 추상클래스로부터 상속받은 자손클래스는 오버라이딩을 통해 조상인 추상크랠스의 추상메소드를 모두 구현해야함
    - 만일 조상으로부터 상속받은 추상메서드 중 하나라도 구현하지 않는다면, 자손클래스 역시 추상클래스로 지정해줘야 함   
  ``` java
  /* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명 */
  abstract 리턴타입 메서드이름();
  ```
### 6.3 추상클래스의 작성
  - 상속
    - 자손 클래스를 만드는데 조상 클래스를 사용 
  - 추상화
    - 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것
    - 계층도가 내려갈수록 구체화 됨
  - abstract 사용 이유
    - 추상메서드로 하는 대신, 아무 내용도 없는 메서드로 작성 가능
    - 그러나, abstract를 붙여서 추상메서드로 선언하는 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위함
   ``` java
   abstract class Unit {
    int x, y;
    abstract void move(int x, int y)
    void stop() {/* 현재 위치에 정지 */}
   }
   class Marine extends Unit {
    void move(int x, int y) {/* 지정된 위치로 이동 */}
    void stimPack() {/* 스팀팩을 사용 */}
   }
   class Tank extends Unit {
    void move(int x, int y) {/* 지정된 위치로 이동 */}
    void changeMode() {/* 공격모드를 변환한다 */}
   }
   class Dropship extends Unit {
    void move(int x, int y) {/* 지정된 위치로 이동 */}
    void load() {/* 선택된 대상을 태운다*/}
    void unload() {/* 선택된 대상을 내린다 */}
   }
   ```
## 7 인터페이스(interface)
### 7.1 인터페이스란?
  - 인터페이스란?
    - 추상클래스의 일종
    - 추상클래스보다 추상화 정도가 높음
    - 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없음
    - 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않음
### 7.2 인터페이스의 작성
  - 작성
  ``` java
  interface 인터페이스이름 {
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
  }
  ```
  - 제약조건
    - 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다
    - 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다
### 7.3 인터페이스의 상속
  - 상속
    - 인터페이스는 인터페이스로부터만 상속받을 수 있음
    - 클래스와는 달리 다중 상속이 가능 즉, 여러 개의 인터페이스로부터 상속을 받는 것이 가능
    - 인터페이스는 클래스와는 달리 object클래스와 같은 최고 조상은 없다
  ``` java
  interface Movable {
    void move(int x, int y);
  }
  
  interface Attackable {
    void attack(Unit u);
  }
  
  interface Fightable extends Moveable, Attackable {}
  ```
### 7.4 인터페이스의 구현
  - implements를 통해 구현가능
  ``` java
  class Fighter implements Fightable {
    public void move () {/* 구현 내용 생략 */
    public void attack () {/* 구현 내용 생략 */} 
  }
  ```
  - implements 구현시 주의해야할 점
    - 위 코드를 보면 구현시 public을 한 것을 볼 수 있음
    - 오버라이딩 시 조상의 메서드보다 같거나 넓은 범위의 접근 제어자를 지정해야한다 
    - 때문에 inferface는 기본이 public abstract void move(int x, int y)이기 때문에 
    - 구현시 public void move() {}인 public으로 해준다
### 7.5 인터페이스를 이용한 다중상속
### 7.6 인터페이스를 이용한 다형성
  - 인터페이스 또한 조상이므로 자손클래스의 인스턴스를 조상타입인 인스턴스가 참조변수로 참조 가능
  - 인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter인스턴스를 Fightable타입의 참조변수로 참조 가능
  ``` java
  Fightable f = (Fightable) new Fighter();
  or
  Fightable f = new Fighter();
  ```
  - 따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로 사용 가능
  ``` java
  void attack(Fightable f) {
    // ...
  }
  ```
  - 아래와 같이 사용 가능
  ``` java
  interface Parseable {
    parse(String fileName);
  }
  
  class ParserManager {
    public static Parseable getParser(String type) {
      if(type.equals("XML")){
        return new XMLParser();
      } else {
        return new HTMLParser();
      }
    }
  }
  
  class XMLParser implements Parseable {
    public void parse(String fileName) {
      System.out.println(fileName + "- XML parsing completed");
    }
  }
  
  
  class HTMLParser implements Parseable {
    public void parse(String fileName) {
      System.out.println(fileName + "- HTML parsing completed");
    }
  }
  
  class ParserTest {
    public static void main(String args[]) {
      Parseable parser = ParserManager.getParser("XML");
      parser.parse("document.xml");
      parser = ParserManager.getParser("HTML");
      paser.parse("document2.html");
    }
  }
  ```
### 7.7 인터페이스의 장점
  - 개발시간을 단축
    - 인터페이스가 작성되면, 이를 사용해 프로그램을 작성하는 것이 가능 
    - 메서드를 호출하는 쪽에서는 메서드의 내용에 관계없이 선언부만 알면 됨
    - 그리고 동시에 다른 한 쪽에서 인터페이스를 구현하는 클래스를 작성하도록 하여,
    - 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행 가능 
  - 표준화 가능
    - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 
    - 보다 일관되고 정형화된 프로그램의 개발 가능 
  - 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있음
    - 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않아 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺을 수 있음 
  - 독립적인 
    - 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능
    - 클래스와 클래스간의 직접적인 관계를 인터페이스를 이용 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍 가능
    - ex) 한 데이터베이스 회사가 제공하는 특정 데이터베이스를 사용하는데 필요한 클래스를 사용해서 프로그램을 작성 했다면 이 프로그램은 다른 종류의 데이터베이스를 사용하기 위해서는 데이터베이스 관련 모든 부분을 번경해야함. 하지만 데이터베이스 관련 인터페이스를 정의하고 이를 이용해 프로그램을 작성하면, 데이터베이스의 종류가 변경되더라도 프로그램을 변경하지 않도록 할 수 있음. 단, 데이터베이스 회사에서 제공하는 클래스도 인터페이스를 구현하도록 요구해야함 
  - 책 7.7 인터페이스 챕터 자세히 보기

###7.8 인터페이스의 이해
  - 인터페이스 이해를 위한 선 이해
    - 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Provider)이 있다
    - 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.(내용은 몰라도 된다)
   ``` java
   class A{
    public void methodA(B b) {
      b.methodB();
    }
   }
   class B{
    public void methodB() {
      System.out.println("methodB()");
    }
   }
   class interfaceTest {
    public static void main(String args[]) {
      A a = new A();
      a.methodA(new B());
    }
   }
   ```
  - 위 코드와 같이 A, B 클래스가 있고 A(User)는 클래스 B(Provider)의 인스턴스를 생성하고 메서드를 호출함
  - 이 두 클래스는 서로 직접적인 관계에 있다
  - 이것을 간단히 'A-B'라 하자
  - 이 경우 클래스 A를 작성하기 위해서는 클래스 B가 이미 작성되어 있어야 한다
  - 그리고 클래스 B의 method()의 선언부가 변경되면, 이를 사용하는 클래스 A도 변경되어야 한다
  - 그러나 클래스 A가 인터페이스를 매개체로 해서 클래스 A가 인터페이스를 통해 클래스 B의 메서드에 접근하도록 하면, 클래스  B에 변경사항이 생기거나 클래스 B와 같은 기능의 다른 클래스로 대체 되어도 A는 전혀 영향을 받지 않도록 하는 것이 가능하다
  ``` java
  interface I {
    methodB();
  }
  
  class B implements I {
    public void methodB() {
      System.out.println("methodB in B class");
    }
  }
  class A{
    public void methodA(I i) {
      i.methodB();
    }
  }
  ```
