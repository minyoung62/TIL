# Binary Search

## 간단한 문제
  ```
  [23, 34, 36, 41, 45, 49, 52, 57, 64, 72, 76, 81, 89]
  위의 오름차순으로 정렬 되어있는 배열중에 45를 찾아라
  ```
### 나이브한 풀이
  - 나이브한 방법은 배열 앞에서부터 또는 뒤에서부터 하나하나 비교하면 된다.
  - 이렇게 되면 배열의 길이가 n이라고 했을 때 O(n)의 시간복잡도가 걸리게된다.

### 개선시킬 수 있는 방법
  - 오름차순이라고 되어있다는 것은 인덱스 0 부분에는 가장작은 값이, 인덱스 마지막 부분에는 가장 큰값으로 정렬되어 있다는 의미이다.
  - 정렬되어 있는 것중 특정 값을 찾아야 한다면 당연히 중간을 선택해야 한다.
  - 왜냐하면 중간을 선택했을 때 52가 되는데 45는 52보다 작다 때문에 중간 인덱스부터 마지막 인덱스까지는 볼 필요가 없게된다.
  - 이러한 이유로 계속 계속 중간에 있는 값을 선택하면 오름차순으로 정렬되어있는 배열의 특정 값을 빠르게 찾을 수 있다.
### 개선된 방법의 소스코드 (이진탐색 코드)
  ``` python
  n, target = 13, 45
  arr = [23, 34, 36, 41, 45, 49, 52, 57, 64, 72, 76, 81, 89]

  idx = -1
  
  # 이진탐색을 진행
  left, right = 0, n - 1
  
  while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
      idx = mid
      break
    if arr[mid] > target:
      right = mid - 1
    else:
      left = mid + 1
  print(idx)
  ```
  - 배열의 길이가 N일 때 시간복잡도는 O(LogN)이다
    
