kkk## 1 사람을 사랑한 기술
## 2 자바와 절차적/구조적 프로그래밍
  ### 다시보는 main() 메서드: 메서드 스택 프레임
  ``` java
    public class Start {
    public static void main(String[] args) {
      System.out.println("Hello OOP!!!");
    } 
  }
  ```
  - JRE가 프로그램 안에 main() 메서드가 있는지 확인
  - JRE는 Start 클래스에 main() 메소드 발견
  - main() 메소드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비 착수
  - 가상의 기계인 JVM에 전원을 넣어 부팅 
  - 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행
  - JVM이 맨 먼저 하는 일은 전처리 과정 
  - 모든 자바 프로그램은 반드시 java.lang 패키지를 포함해야함 때문에 JVM은 가장 먼저 java.lang 패키지를 스태틱 영역에 가져다 놓음 
  - 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 넣음 
  - main() 메서드를 스택영역에 적재
  - System.out.println("Hello OOP!!") 구문 실행
  - 화면에 출력 
  - main() 메서드 스택영역에서 소멸 
  - JRE는 JVM을 종료 JRE 자체도 운영체제 상의 메모리에서 사라짐 
  
  ### 멀티 스레드/ 멀티 프로세스의 이해
  - 멀티 스레드의 메모리에 스택 영역은 스레드 개수만큼 분할해서 사용(스태틱과 힙은 공유)
  - 멀티 프로세스는 다수의 데이터 저장 영역, 다수의 스태틱, 스택, 힙 영역을 가짐 
  - 자바 웹 프로그래밍에서 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성
    - 이유는 멀티 스레드는 스태틱과 힙을 공유하기 때문에 멀티 프로세스보다 비교적 가볍고 효율적!
  - 멀티 스레드의 문제점
    - 전역 변수의 문제점 존재 
  - 문제 코드 
  ``` java
  public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
      Start6 t1 = new Start6();
      Start6 t2 = new Start6();

      t1.start();
      t2.start();
    }

    public void run() {
      for (int count = 0; count < 10; count++) {
        System.out.println(share++);

        try {
          sleep(1000);
        } catch (InterruptedException e) {
        }
      }
    }
  }
  
  ```
## 자바와 객체 지향
  - 객체 지향의 4대 특성
    - 캡슐화(정보 은닉)
    - 상속(재사용)
    - 추상화(모델링)
      - 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합하는 것 = 모델링
      - 클래스 설계에서 추상화가 사용됨
      - 객체 지향에서 추상화의 결과는 클래스
      - 상속을 통한 추상화, 구체화
      - 인터페이스를 통한 추상화
      - 다형성을 통한 추상화
      - 자바는 class라는키워드를 통해 추상화 제공
      - 자바는 "클래스 객체_참조_변수 = new 클래스();"를 통해 클래스와 객체 관계를 표현     
    - 다형성(사용 편의)    

## 자바가 확장한 객체 지향
  ### 클래스 생성 시의 실행 블록, static 블록
  - 객체 생성자는 있지만 클래스 생성자는 존재하지 않음
  - 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록인 static 블록이 있음
  ``` java
  public class 동물 {
    static {
      System.out.println("동물 클래스 레디 온!");
    }
  }
  ```
  ``` java
  public class Driver01() {
    public static void main(String[] args) {
      동물 뽀로로 = new 동물(); 
    }
  }
  ```
  - 결과 : 동물 클래스 레디 온!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      동물 뽀로로 = new 동물(); 
    }
  } 
  ```
  - 결과 : main 메서드 시작!\n 동물 클래스 레디온 
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      System.out.println(Animal.age);
    }
  }

  class Animal {
    static int age = 0;
    static {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!\n Animal 클래스 ready on!\n 0
  - 정리
    - 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 메모리의 스태틱 영역에 로딩, 이때 단 한번 해당 클래스의 static 블록이 실행
  - 클래스가 제일 처음 사용되는 경우는 아래 3가지 경우가 있음
    - 클래스의 정적 속성을 사용할 때
    - 클래스의 정적 메서드를 사용할 때
    - 클래스의 인스턴스를 사용할 때
  ### final 키워드
  - final은 마지막, 최종의 의미 클래스, 변수, 메서드에 사용
  - final과 클래스
    ``` java
    public final class 고양이 {}
    ```
    - 상속을 허락하지 않겠다는 의미
  - final과 변수
    ``` java
    public class 고양이{
      final static int 정적상수1 = 1;
      final static int 정적상수2;
      
      final int 객체상수1 = 1;
      final int 객체상수2 = 2;
      
      static {
        정적상수2 = 2;
        
        // 상수는 한 번 초기화되면 값을 변경할 수 없다
        // 정적상수2 = 4;
      }
      
      고양이() {
        객체상수2 = 2;
        
        //상수는 한 번 초기화되면 값을 변경할 수 없다
        //객체상수2 = 4;
        
        final int 지역상수1 = 1;
        final int 지역상수2;
        
        지역상수2 = 2;
      }
    }
    ```
    - 정적 생성자에 해당하는 static 블록 내부에서 초기화 가능 
    - 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화 가능
  - final과 메서드
    - 오버라이딩 금지
### instanceof 연산자
  - 인스턴스는 클래스를 통해 만들어진 객체
  - instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자 
  - instanceof 연산자는 결과로 true 또는 false를 반납 
  - 사용법
    - 객체_참조_변수 instanceof 클래스명
  ``` java
  class 동물 {
    
  }
  class 조류 extends 동물{
  
  }
  class 펭귄 extends 조류{
  
  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      조류 조류객체 = new 조류();
      펭귄 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  class 동물 {

  }

  class 조류 extends 동물 {

  }

  class 펭귄 extends 조류 {

  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      동물 조류객체 = new 조류();
      동물 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  interface 날수있는 {

  }

  class 박쥐 implements 날수있는 {

  }

  class 참새 implements 날수있는 {

  }

  public class Driver {
    public static void main(String[] args) {
      날수있는 박쥐객체 = new 박쥐();
      날수있는 참새객체 = new 참새();

      System.out.println(박쥐객체 instanceof 날수있는);
      System.out.println(박쥐객체 instanceof 박쥐);

      System.out.println(참새객체 instanceof 날수있는);
      System.out.println(참새객체 instanceof 참새);
    }
  }
  ```
  - 결과 : 모두 true
## 객체 지향 설계 5원칙 - SOLID
  ### SRP(단일 책임 원칙)
  - ![image](https://user-images.githubusercontent.com/61530368/176111724-925103cb-4dcd-4805-945e-bad94d0bddca.png)
    - 남자 클래스에 많은 역할(책임) 존재 
  - ![image](https://user-images.githubusercontent.com/61530368/176111981-2dc5d090-025e-464c-9af4-6d99a29f04ef.png)
    - 남자 클래스에 단일 책임 원칙을 적용해 여러 개의 클래스로 분리 
  - ``` java
    public class 강아지 {
    final static Boolean 숫컷 = true;
    final static Boolean 암컷 = false;
    Boolean 성별;

    void 소변보다() {
        if (this.성별 == 숫컷) {
          // 한쪽 다리를 들고 소변을 본다.
        } else {
          // 뒤다리 두 개로 앉은 자세로 소변을 본다.
        }
      }
    }
    ```
    - 강아지 클래스의 소변보다() 메서드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 하기에 단일 책임(행위)원칙을 위배 (대표적인 냄새가 바로 분기 처리를 위한 if문)
  - 리팩토링
  ``` java
  public abstract class 강아지 {
    abstract void 소변보다();
  }
  
  public class 숫컷강아지 extends 강아지 {
    void 소변보다() {
      // 한쪽 다리를 들고 소변을 본다.
    }
  }
  
  public class 암컷강아지 extends 강아지 {
    void 소변보다() {
      // 뒤다리 두 개로 앉은 자세로 소변을 본다.
    }
  }
  ```
  - 단일 책임의 원리는 모델링 과정을 담당하는 추상화와 결부되어있다
### OCP(개방 폐쇄 원칙)
  - 소프트웨어 엔티티(클래스, 모듈, 함수)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야한다 
  - JDBC의 개방 폐쇠 원칙
    - ![image](https://user-images.githubusercontent.com/61530368/176116129-dda01569-7771-4522-bc8f-5cef3112ce38.png)
    - 클라이언트는 데이터베이스가 바뀌더라도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없음
  - 자바에서 개방 폐쇄 원칙
    - 자가 개발자가 소스코드를 작성 
    - 실행시 여러가지 운영체제에서 실행될 수 있음 
    - 각 운영체제별 JVM과 목전파일(.class)이 있기에 개발자는 다양한 구동 환경에 대해 걱정하지 않고 실행 가능
### LSP(리스코프 치환 원칙)
  - 서브타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다
    - = 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다 
  - ![image](https://user-images.githubusercontent.com/61530368/176117525-7e27034d-e087-470c-9ef6-e5d18d8b7232.png)
    - 리스코프 치환 원칙 위반 사례 - 계층도/조직도
  - ![image](https://user-images.githubusercontent.com/61530368/176117641-0ce2194a-e1a2-478f-a231-744e68d0dbd6.png)
    - 리스코프 치환 원칙 적용 사례 - 분류도
### ISP(인터페이스 분리 원칙)
  - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
  - ![image](https://user-images.githubusercontent.com/61530368/176119977-13cf2e8a-6b65-4c29-8496-d25f2554d8b3.png)
    - 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스로 제한
    - 어머니와 있을 때는 아들 인터페이스로 제한
    - 직장 상사 앞에서는 사원 인터페이스로 제한
    - 소대장 앞에서는 소대원 인터페이스로 제한 
    - 이것이 바로 인터페이스 분할 원칙의 핵심
  - 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책
  - 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책
    - 인터페이스 최소주의 원칙으로 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공
    - 상위 클래스는 풍부할수록 좋고, 인터페이스는 작을수록 좋다 
  - "상위 클래스는 풍부할수록 좋고, 인터페이스는 작을수록 좋다"의 이유
    - ![image](https://user-images.githubusercontent.com/61530368/176121250-a48cfeb7-d4c9-47d8-a658-7ed1bf92566a.png)
    - 빈약한 상위 클래스
    ``` java
    public class Driver {
      public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
            "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
            "19-12345678");

        System.out.println(김학생.이름);
        System.out.println(이군인.이름);

        // System.out.println(김학생.생일); // 사용불가
        // System.out.println(이군인.생일); // 사용불가

        System.out.println(((학생) 김학생).생일); // 캐스팅 필요
        System.out.println(((군인) 이군인).생일); // 캐스팅 필요

        // System.out.println(김학생.주민등록번호); // 사용불가
        // System.out.println(이군인.주민등록번호); // 사용불가

        System.out.println(((학생) 김학생).주민등록번호);
        // 캐스팅 필요
        System.out.println(((군인) 이군인).주민등록번호);
        // 캐스팅 필요

        김학생.먹다();
        이군인.먹다();

        // 김학생.자다(); // 사용불가
        // 이군인.자다(); // 사용불가

        ((학생) 김학생).자다(); // 캐스팅 필요
        ((군인) 이군인).자다(); // 캐스팅 필요

        // 김학생.소개하다(); // 사용불가
        // 이군인.소개하다(); // 사용불가

        ((학생) 김학생).소개하다(); // 캐스팅 필요
        ((군인) 이군인).소개하다(); // 캐스팅 필요

        ((학생) 김학생).공부하다(); // 캐스팅 필요
        ((군인) 이군인).훈련하다(); // 캐스팅 필요
      }
    }
    ```
      - 상속의 혜택을 제대로 누리지 못함 
    - 풍부한 상위 클래스
    ``` java
    public class Driver {
      public static void main(String[] args) {
        사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), "20000101-1234567",
            "20190001");
        사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), "19981231-1234567",
            "19-12345678");

        System.out.println(김학생.이름);
        System.out.println(이군인.이름);

        System.out.println(김학생.생일);
        System.out.println(이군인.생일);

        System.out.println(김학생.주민등록번호);
        System.out.println(이군인.주민등록번호);

        // System.out.println(김학생.학번); // 사용불가
        // System.out.println(이군인.군번); // 사용불가

        System.out.println(((학생) 김학생).학번);
        // 캐스팅 필요
        System.out.println(((군인) 이군인).군번);
        // 캐스팅 필요

        김학생.먹다();
        이군인.먹다();

        김학생.자다();
        이군인.자다();

        김학생.소개하다();
        이군인.소개하다();

        // 김학생.공부하다(); // 사용불가
        // 이군인.훈련하다(); // 사용불가

        ((학생) 김학생).공부하다(); // 캐스팅 필요
        ((군인) 이군인).훈련하다(); // 캐스팅 필요
      }
    }
    ```
### DIP(의존 역전 원칙)
  - 고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야한다. 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야한다. 자주 변경되는 구체 클래스에 의존하지 마라!
  - ![image](https://user-images.githubusercontent.com/61530368/176124014-14fc880d-b29d-4d86-8d24-a98d201c6662.png)
    - 자동차는 한 번 사면 몇 년은 타야 하는데 스노우타이어는 계쩔이 바뀌면 일반 타이어로 교채해야함
  - ![image](https://user-images.githubusercontent.com/61530368/176124267-29fb1a5f-afa2-4815-ace2-43d655dae195.png)
    - 자동차가 구체체적인 타이어들(스노우타이어, 일반타이어, 광폭타이어)이 아닌 추상화된 타이어 인터페이스에 의존하게 함
    - 이는 개방 폐쇄 원칙(OCP)와 유사
    - 이렇게 하나의 해결책을 찾으면 그 안에 여러 설계 원칙이 녹아있는 경우가 많음
    - 즉, 이처럼 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지지 않게 하는 것이 의존 역전 원칙
### 객체 지향 세계와 SOLID 정리 
  - SRP(단일 책임 원칙) : 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다
  - OCP(개방 폐쇄 원칙) : 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다
  - LSP(리스코프 치환 원칙) : 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다
  - ISP(인터페이스 분리 원칙) : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다
  - DIP(의존 역전 원칙) : 자신보다 변하기 쉬운 것에 의존하지마라 
## 스프링이 사랑한 디자인 패턴

