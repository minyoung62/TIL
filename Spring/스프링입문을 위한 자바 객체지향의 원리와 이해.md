kkk## 1 사람을 사랑한 기술
## 2 자바와 절차적/구조적 프로그래밍
  ### 다시보는 main() 메서드: 메서드 스택 프레임
  ``` java
    public class Start {
    public static void main(String[] args) {
      System.out.println("Hello OOP!!!");
    } 
  }
  ```
  - JRE가 프로그램 안에 main() 메서드가 있는지 확인
  - JRE는 Start 클래스에 main() 메소드 발견
  - main() 메소드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비 착수
  - 가상의 기계인 JVM에 전원을 넣어 부팅 
  - 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행
  - JVM이 맨 먼저 하는 일은 전처리 과정 
  - 모든 자바 프로그램은 반드시 java.lang 패키지를 포함해야함 때문에 JVM은 가장 먼저 java.lang 패키지를 스태틱 영역에 가져다 놓음 
  - 다음으로 JVM은 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 넣음 
  - main() 메서드를 스택영역에 적재
  - System.out.println("Hello OOP!!") 구문 실행
  - 화면에 출력 
  - main() 메서드 스택영역에서 소멸 
  - JRE는 JVM을 종료 JRE 자체도 운영체제 상의 메모리에서 사라짐 
  
  ### 멀티 스레드/ 멀티 프로세스의 이해
  - 멀티 스레드의 메모리에 스택 영역은 스레드 개수만큼 분할해서 사용(스태틱과 힙은 공유)
  - 멀티 프로세스는 다수의 데이터 저장 영역, 다수의 스태틱, 스택, 힙 영역을 가짐 
  - 자바 웹 프로그래밍에서 서블릿은 요청당 프로세스가 아닌 요청당 스레드를 생성
    - 이유는 멀티 스레드는 스태틱과 힙을 공유하기 때문에 멀티 프로세스보다 비교적 가볍고 효율적!
  - 멀티 스레드의 문제점
    - 전역 변수의 문제점 존재 
  - 문제 코드 
  ``` java
  public class Start6 extends Thread {
    static int share;

    public static void main(String[] args) {
      Start6 t1 = new Start6();
      Start6 t2 = new Start6();

      t1.start();
      t2.start();
    }

    public void run() {
      for (int count = 0; count < 10; count++) {
        System.out.println(share++);

        try {
          sleep(1000);
        } catch (InterruptedException e) {
        }
      }
    }
  }
  
  ```
## 자바와 객체 지향
  - 객체 지향의 4대 특성
    - 캡슐화(정보 은닉)
    - 상속(재사용)
    - 추상화(모델링)
      - 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합하는 것 = 모델링
      - 클래스 설계에서 추상화가 사용됨
      - 객체 지향에서 추상화의 결과는 클래스
      - 상속을 통한 추상화, 구체화
      - 인터페이스를 통한 추상화
      - 다형성을 통한 추상화
      - 자바는 class라는키워드를 통해 추상화 제공
      - 자바는 "클래스 객체_참조_변수 = new 클래스();"를 통해 클래스와 객체 관계를 표현     
    - 다형성(사용 편의)    

## 자바가 확장한 객체 지향
  ### 클래스 생성 시의 실행 블록, static 블록
  - 객체 생성자는 있지만 클래스 생성자는 존재하지 않음
  - 그러나 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록인 static 블록이 있음
  ``` java
  public class 동물 {
    static {
      System.out.println("동물 클래스 레디 온!");
    }
  }
  ```
  ``` java
  public class Driver01() {
    public static void main(String[] args) {
      동물 뽀로로 = new 동물(); 
    }
  }
  ```
  - 결과 : 동물 클래스 레디 온!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      동물 뽀로로 = new 동물(); 
    }
  } 
  ```
  - 결과 : main 메서드 시작!\n 동물 클래스 레디온 
  ``` java
  public class Driver02 {
    public static void main(String[] args) {
      System.out.println("main 메서드 시작!");
      System.out.println(Animal.age);
    }
  }

  class Animal {
    static int age = 0;
    static {
      System.out.println("main 메서드 시작!");
    }
  }
  ```
  - 결과 : main 메서드 시작!\n Animal 클래스 ready on!\n 0
  - 정리
    - 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 메모리의 스태틱 영역에 로딩, 이때 단 한번 해당 클래스의 static 블록이 실행
  - 클래스가 제일 처음 사용되는 경우는 아래 3가지 경우가 있음
    - 클래스의 정적 속성을 사용할 때
    - 클래스의 정적 메서드를 사용할 때
    - 클래스의 인스턴스를 사용할 때
  ### final 키워드
  - final은 마지막, 최종의 의미 클래스, 변수, 메서드에 사용
  - final과 클래스
    ``` java
    public final class 고양이 {}
    ```
    - 상속을 허락하지 않겠다는 의미
  - final과 변수
    ``` java
    public class 고양이{
      final static int 정적상수1 = 1;
      final static int 정적상수2;
      
      final int 객체상수1 = 1;
      final int 객체상수2 = 2;
      
      static {
        정적상수2 = 2;
        
        // 상수는 한 번 초기화되면 값을 변경할 수 없다
        // 정적상수2 = 4;
      }
      
      고양이() {
        객체상수2 = 2;
        
        //상수는 한 번 초기화되면 값을 변경할 수 없다
        //객체상수2 = 4;
        
        final int 지역상수1 = 1;
        final int 지역상수2;
        
        지역상수2 = 2;
      }
    }
    ```
    - 정적 생성자에 해당하는 static 블록 내부에서 초기화 가능 
    - 객체 상수 역시 선언 시에, 또는 객체 생성자 또는 인스턴스 블록에서 초기화 가능
  - final과 메서드
    - 오버라이딩 금지
### instanceof 연산자
  - 인스턴스는 클래스를 통해 만들어진 객체
  - instanceof 연산자는 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자 
  - instanceof 연산자는 결과로 true 또는 false를 반납 
  - 사용법
    - 객체_참조_변수 instanceof 클래스명
  ``` java
  class 동물 {
    
  }
  class 조류 extends 동물{
  
  }
  class 펭귄 extends 조류{
  
  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      조류 조류객체 = new 조류();
      펭귄 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  class 동물 {

  }

  class 조류 extends 동물 {

  }

  class 펭귄 extends 조류 {

  }

  public class Driver {
    public static void main(String[] args) {
      동물 동물객체 = new 동물();
      동물 조류객체 = new 조류();
      동물 펭귄객체 = new 펭귄();

      System.out.println(동물객체 instanceof 동물);

      System.out.println(조류객체 instanceof 동물);
      System.out.println(조류객체 instanceof 조류);

      System.out.println(펭귄객체 instanceof 동물);
      System.out.println(펭귄객체 instanceof 조류);
      System.out.println(펭귄객체 instanceof 펭귄);

      System.out.println(펭귄객체 instanceof Object);
    }
  }
  ```
  - 결과 : 모두 true
  ``` java
  interface 날수있는 {

  }

  class 박쥐 implements 날수있는 {

  }

  class 참새 implements 날수있는 {

  }

  public class Driver {
    public static void main(String[] args) {
      날수있는 박쥐객체 = new 박쥐();
      날수있는 참새객체 = new 참새();

      System.out.println(박쥐객체 instanceof 날수있는);
      System.out.println(박쥐객체 instanceof 박쥐);

      System.out.println(참새객체 instanceof 날수있는);
      System.out.println(참새객체 instanceof 참새);
    }
  }
  ```
  - 결과 : 모두 true
## 객체 지향 설계 5원칙 - SOLID
  ### SRP(단일 책임 원칙)
  - 
