## LIS란?
  - 가장 긴 증가 부분 수열이다 

## 간단한 문제
  ```
  [10, 30, 25, 40, 28, 45]
  가장 긴 증가 부분 수열의 길이를 구하라
  ```
### 나이브한 풀이 
  - 배열의 길이가 6이고 배열의 첫 번째 인덱스 0부터 마지막 인덱스 5까지 한 칸씩 잡고 잡은 인덱스에서 왼쪽으로 늘리면서 증가하는 부분 수열을 확인한다.
  - 배열의 길이가 n일 때 n개의 인덱스를 잡는 O(n)
  - 그리고 왼쪽으로 늘리는 경우 O(n)
  - 증가하는 부분 수열인지 확인하는 경우 O(n)이다.
  - 때문에, 총 O(n^3)의 시간복잡도가 나온다.
### 개선 방법
  - dp테이블을 활용하여 현재 위치를 가장 긴 증가하는 부분 수열의 증가 횟수로 생각하면 증가하는 부분 수열인지 확인하는 경우가 걸리는 O(n)을 O(1)로 줄일 수 있다. 

### 개선된 코드(dp활용)
  ``` python
  n = int(input())

  a = list(map(int, input().split()))

  #dp[i]:= i번째 위치는 가장 긴 증가하는 부분 수열의 증가 횟수 
  dp = [0] * n
  
  # dp table init(자기자신은 증가 횟수가 1로 초기화)
  for i in range(n):
    dp[i] = 1

  # dp table 채우기
  for i in range(1, n):
      for j in range(i):
          if a[i] > a[j]:
              dp[i] = max(dp[i], dp[j] + 1)

  print(max(dp))
  ```
  - 총 시간복잡도 O(n^2)
