# 1 기초 정수론
##  1.1수체계
  - ![image](https://user-images.githubusercontent.com/61530368/172412019-81862edf-e6fb-4084-8f11-fdc29bf42c38.png)

##  1.2항등원과 역원
  - 항등원 
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, x가 나오게 하는 원소 y
    - 덧셈, 뺄셈 연산에 대한 항등원 -> 0 (x + y = x, x - y = x)
    - 곱셈, 나눗셈 연산에 대한 항등원 -> 1 (x * y = x, x/y = x)
  - 역원
    - 임의의 원소 x에 특정 연산 O를 수행하였을 때, 해당 연산의 항등원이 나오게 하는 원소 y
    - 덧셈 연산에 대한 역원 -> -x (x + y = 0, x - y = 0)
    - 곱셈 연산에 대한 역원 -> 1/x (x * y = 1, x/y = 1)  
##  1.3 정수 집합과 이항 연산
  - 정수 집합
    - 음의 무한대에서 양의 무한대까지의 모든 정수로 구성된 집합
    - Z = { -무한대, ..., -2, -1, 0, 1, 2,  ..., 무한대}
    - a, b ∈ Z : 임의의 두 정수 a와 b   
  - 이항 연산
    - 두 입력 값으로부터 하나의 결과 값을 산출하는 연산 
    - * 나눗셈은 연산 결과로 목과 나머지를 산출하므로, 이항 연산에 속하지 않는다 
##  1.4 나눗셈, 나눗셈 정리, 가분성
  - 나눗셈
    - a ∈ Z를 n ∈ Z (n != 0)으로 나누면
    - 목(quotient) : q ∈ Z
    - 나머지(remainder): r ∈ Z
    - a = qn + r
    - r = q - qn
    - 제한사항
      - n > 0 
      - r >= 0
      - a가 음수일 경우 q와 r은 음수이다 
      - 이 때, r이 음이 아닌 정수라는 제약사항일 때는  -> q에서 1을 빼고, r에 n을 더하여 음이 아닌 정수로 만든다    
    - 나눗셈은 이항 연산이 아닌 관계식이다
  - 나눗셈 정리 
    - 임의의 두 정수 a, b ∈ Z (b > 0)가 존재한다면, a = qb + r을 만족하는 두 정수 q,r ∈ Z이 항상 유일하게 존재한다 
  - 가분성
    - a를 n으로 나눌 때, 나머지가 0이라면, (즉, a = qn + r 에서 r = 0 )
    - n은 a의 약수(divisor)이다
    - a는 n으로 나눌 수 있다
    - n | a
    - 가분성 성질
      -  만약 a | 1 이면 a = +-1
      -  만약 a | b 이고 b | a 이면 a = +-b
      -  만약 a | b 이고 b | c 이면 a | c
      -  만약 a | b 이고 a | c 이면 a | (mb + nc) (m, n ∈ Z)
  - 약수
    - 양의 정수는 하나 이상의 약수를 갖는다
    - 정수 1은 하나의 약수, 즉 1만을 가진다
    - 모든 양의 정수는 최소 2개 이상의 약수를 가진다
  - 최대 공약수
    - 공약수 (Common divisor)
      - 두 양의 정수가 갖는 공통의 약수 
    - 최대 공약수 (Greatest Common Divisor: GCD)
      - 두 양의 정수의 공약수중에서 가장 큰 정수
      - 두 양의 정수의 최대 공약수 = 두 정수를 나누는 가장 큰 정수 
##  1.5 유클리드 알고리즘
  - 유클리드 알고리즘
    - 두 양의 정수의 최대 공약수를 찾는 알고리즘
    - 기본 원리
      - gcd(a, 0) = a
      - gcd(a, b) = gcd(b, r) (r = a를 b로 나눈 나머지)
    - 예시) 36과 10의 최대공약수를 유클리드 알고리즘으로 계산하라
    -   gcd(36, 10) = gcd(10, 6) = gcd(6, 4) = gcd(4, 2) = gcd(2, 0) = 2
  - 
##  1.6 확장 유클리드 알고리즘

# 2 기초 정수론
## 2.1 선형 디오판투스 방정식
## 2.2 모듈러 연산
  - 모듈러 연산
    - 나머지 연산의 두 결과 값 중 나머지 r(>= 0)만 출력하는 연산
    - 27 mod 5 = 2
    - -18 mod 14 = 10 
      - r > 0이어야 하므로, a = qn + r에서
      - q = q - 1
      - r = r + n
      - 을 통해 r을 양의 정수로 바꿀 수 있음 
## 2.3 최소 잉여 집합과 모듈러 합동
  - 최소 잉여 집합
    - 모듈로 n을 이용하는 모듈로 연산의 결과는 0 ~ n -1 사이의 값을 갖는다
    - 이때, 정수 n에 대한 모듈로 연산 결과는 하나의 집합을 생성하는데, 이 집합을 "모듈로 n의 최소 잉여 집합 Zn"이라 한다
    - Zn = {0,1,2, ..., (n-1)}
    - ex) Z2 = {0, 1}
    - ex) Z6 = {0, 1, 2, 3, 4, 5}
  - 모듈러 합동
    - 모듈로 연산에서 2, 12, 22, 52에 대해 "mod 10"을 수행하면
    - 2 mod 10 = 2
    - 12 mod 10 = 2
    - 22 mod 10 = 2
    - 52 mod 10 = 2
    - 즉, 모두 같은 결과 값 r = 2를 가진다
    - 이때, 2와 12, 22 그리고 52는 "mod 10"에 대하여 합동이다
    - 합동 연산자 "≡"
      - a ≡ b (mod x): 두 정수 a와 b는 "mod x"에 대하여 서로 합동이다
      - 즉, a와 b는 x로 나누었을 때, 서로 같은 나머지를 갖는다      
## 2.4 잉여류와 모듈러 연산의 성질
  - 잉여류(Residue classes)
    - n으로 합동인 정수의 집합
    - [a] 또는 [a]n으로 표기
      - 즉, [a]n은 n으로 나누었을 때, 나머지가 a가 되는 모든 정수들의 집합
    - ex) n = 5일 때 잉여류
      - [0] = 5로 나누었을 때 나머지가 0인 정수들의 집합
      - [1] = 5로 나누었을 때 나머지가 1인 정수들의 집합
      - [2] = 5로 나누었을 때 나머지가 2인 정수들의 집합
      - [3] = 5로 나누었을 때 나머지가 3인 정수들의 집합
      - 아래와 같이 표현함
      - [0] = {..., 0, 5, 10, 15,...}
      - [1] = {..., 6, 11, 16, ...} 
  - Zn에서의 연산
    - 잉여류 Zn에서 덧셈, 뺄셈, 곱셈 연산 수행 가능
    - Z15의 7과 14를 더하시오 -> (7 + 14) mod 15 -> 21 mod 15 = 6
  - 모듈러 연산의 성질
    - (a + b) mod n = [(a mod n) + (b mod n)] mod n
    - (a - b) mod n = [(a mod n) + (b mod n)] mod n
    - (a * b) mod n = [(a mod n) * (b mod n)] mod n
    - 암호 알고리즘에 모듈러 연산 적용 시 a와 b의 값은 일반적으로 매우 큰 수
    - 따라서, 계산 시 발생하는 오버헤드를 모듈러 연산의 성질로 완화할 수 있다
## 2.5 모듈러 역원
  - 덧셈에 대한 역원
    - 모듈러 연산에서 각각의 정수는 덧셈에 대한 역원을 갖는다
    - 어떤 정수와 그 정수의 덧셈에 대한 역원의 합은 모듈로 n에 대하여 0과 합동이다
    - 즉, Zn에서 두 수 a와 b는 다음과 같이 서로 덧셈에 대한 역원이 된다
      - a + b ≡ 0 mod n 
    - 따라서, Zn에서 a의 덧셈에 대한 역원은 b = n - a
    - ex ) Z10에서 모든 덧셈에 대한 역원 쌍
      - 덧셈에 대한 역원의 쌍 총 6개
      - (0,0), (1, 9), (2, 8), (3, 7), (4, 6), (5, 5)
  - 곱셈에 대한 역원
    - 즉, Zn에서 두 수 a와 b가 아래의 성질을 만족하면 이들은 서로 곱셈에 대한 역원이 된다
      - a * b ≡ 1 mod n
    - 모듈로 연산에서 정수는 곱셈에 대한 역원이 있을 수도 있고, 없을 수도 있음
    - 만약 곱셈에 대한 역원이 있따면, 그 정수와 해당하는 곱셈에 대한 역원의 곲은 모듈로 n에서 1과 합동
    - a가 Zn에서 곱셈에 대한 역원을 갖기 위한 필요충분조건
      - gcd(n, a) = 1
    - 이 경우 n과 a는 서로소이다
      - 서로소란 두 수 a와 b의 최대공약수가 1일 때, 두 수는 서로소이다
    - ex) Z10에서 곱셈에 대한 역원
      - (1, 1), (3, 7), (9, 9)
      - (1 * 1) mod 10 = 1
      - (3 * 7) mod 10 = 1
      - (9 * 9) mod 10 = 1 
# 3 고전 대칭 키 암호
## 3.1 대칭 키 암호의 기본 개념
  - Kerchoff의 원리
    - 암호체계의 안정성은 암호 알고리즘의 비밀을 지키는데 의존되어서는 안되며
    - 키의 비밀을 지키는데 의존되어야 한다
  - 용어 설명
    - 평문(Plaintext): 송신자가 수신자에게 보내는 본래의 메시지
    - 암호 알고리즘(Encryption algorithm): 평문을 암호문으로 변경하는 알고리즘
    - 복호 알고리즘(Decryption algorithm): 암호문을 평문으로 복원하는 알고리즘
    - 공유 비밀 키(Shared secret key): 송신자와 수신자가 함께 공유하는 암호화와 복호화에 사용되는 값
    - 암호(Cipher): 암호 알고리즘과 복호 알고리즘을 통칭 
  - 대칭 키 암호체계의 특징
    - 송신자와 수신자가 비밀 키를 공유함 즉, 암호 키와 복호 키가 동일 
    - ![image](https://user-images.githubusercontent.com/61530368/172433820-e3f5f460-3ed6-4160-9799-ffa0d259e8bc.png)
  - 고전 대칭 키 암호체계의 종류
    - 대치 암호: 평문(암호문)내 각 기호를 다른 기호로 치환하여 암호(복호화) 수행
    - 전치 암호: 평문(암호문)내 각 기호의 위치를 다른 위치로 변환하여 암호화(복호화) 수행   
## 3.2 대치 암호
  - 대치 암호란?
    - 하나의 기호를 다른 기호로 대체하여 암호화/복호화 수행
    - 대치암호는 단일문자암호, 다중문자 암호로 분류 
    - 단일 문자 암호
      - 평문에서 하나의 문자(기호)가 위치에 상관없이 암호문에서 항상 같은 문자(기호)로 대체
      - 항상 일대일 대응 관계를 갖는 암호체계 
## 3.2 전치 암호
## 3.4 스트림 암호와 블록 암호

# 4 암호 공격의 기본 개념
## 4.1 암호 공격의 개념
  - 암호 공격
    - 송신자와 수신자 이외의 허가 받지 않은 제3자가 암호 시스템을 공격하여 공개되지 않은 키를 불법적으로 회득하거나, 이를 이용하여 암호문의 내용을 가로채는 행위
    ![image](https://user-images.githubusercontent.com/61530368/172436471-0ae167fa-830e-4823-adee-66d6e5278aa3.png)
  - 수동적 공격
    - 메시지의 도청: 공격자가 전송되는 메시지를 도중에 가로채어 그 내용을 외부로 노출시키는 공격, 메시지의 내용을 공격하는 개념
  - 트래픽 분석
    - 존송 메시지의 암호화로 도청을 통한 메시지 내용 파악이 불가능한 경우, 송신자와 수신자의 메시지 전송 트래픽을 분석하여 암호문의 내용을 가로채어 해독하거나 이를 공개하는 개념
  - 능동적 공격
    - 메시지 변조: 전송되는 메시지 순서바꿈, 일부분을 다른 멧지ㅣ로 대체하여 불법적인 효과 발생
    - 삽입 공격: 공격자가 정당한 송신자로 가장 특정 수신자에게 메시지를 보내어 불법적인 효과를 발생
    - 삭제 공격: 정상적인 통신 시설의 사용과 관리를 방해하는 서비스 거부 등을 통해, 특정 수신자에게 전송되는 메시지의 전부 또는 일부를 삭제하는 공격
    - 재생 공격: 공격자가 이전에 특정 송신자와 수신자 간에 행해졌던 통화내용을 도청하여 보관 나중에 재생하여 전송하는 공격 
  - 암호 공격 방식
    - 암호문 단독 공격: 공격자는 단지 암호문만 갖고 있음 이로부터 평문 또는 키를 찾음
    - 기지 평문 공격: 공격자는 일정량의 평문에 대응하는 암호문을 알고 있는 상태에서 암호문의 내용을 해독하는 방법
    - 선택 평문 공격: 공격자가 암호 시스템에 접근하여 평문을 선택, 해당 평문에 해당하는 암호문을 회득한 후, 키 또는 평문을 추정하여 암호문의 내용을 해독
    - 선택 암호문 공격: 공격자가 암호 복호기에 접근하여 암호문에 대한 평문을 회득하여 암호를 해독
  - 암호 시스템의 안전성
    - 계산적 안전성: 암호 시스템을 공격하기 위해 필요한 계산량이 매우 많아서 현실적으로 공격할 수 없는 경우
    - 증명 가능한 안전성: 암호 시스템에서 사용중인 암/복호화 알고리즘이 어렵다고 알려진 문제와 등가라서 현실적으로 해결(공격)할 수 업슨ㄴ 경우
    - 절대적 안전성: 무한한 계산능력을 보유하고 있어도 암호 시스템을 공격할 수 없는 경우(= 무조건적 안전성)
  - 암호 알고리즘 개발자의 목표
    - 암호 해독 비용이 암호화된 정보의 가치를 초과할 수 있는 알고리즘 개발
    - 암호 해독 시간이 암호화된 정보의 유효 기간을 초과할 수 있는 알고리즘    
## 4.2 암호 공격 방법
  - 전수조사 공격 
    - 공격자는 키의 집합을 미리 알고 있다고 가정
    - 모든 가능한 키를 사용 암호문을 복호화하며, 의미 있는 평문이 도출 될 때 까지 이를 반복
  - 통계적인 공격(Statistical attack)
    - 공격자가 평문 언어의 고유한 특징으로부터 정보를 얻음
    - 예를 들어, 평문이 영어일 때 공격자는 암호문에서 가장 빈번하게 사용  
  - 패턴 공격
    - 평문 언어의 특징은 드러나지 않지만 암호문에 어떤 패턴이 존재할 경우, 이를 분석하여 키 유추
  - 암호문 단독 공격
    - 공격자는 암호문 C만을 갖고 있는 상황
    - 공격자가 암호문 C로부터 평문 P또는 키 K를 찾아내는 방법
    - ![image](https://user-images.githubusercontent.com/61530368/172549206-c365ab46-7783-4b51-b4c4-73b4fcfffdc0.png)
  - 기지 평문 공격 (Known plain text attack)
    - 기지 평문 공격(=알려진 평문 공격)은 공격자가 평문과 암호문을 모두 알고 있을 때 사용할 수 있는 암호 해독 기법
    - 즉, 공격자는 일정량의 평문 P에 대응하는 암호문 C를 알고 있을 때
    - 이 때, 공격자는 암호문 C와 평문 P의 관계로부터 키 K나 복호화 알고리즘을 추정 가능
    - 따라서, 기지 평문 공격의 최종 목표는 복호키를 찾는 것
    - ![image](https://user-images.githubusercontent.com/61530368/172549632-3953cdf3-0e70-40d9-9d80-5362f4dcb8f4.png)
  - 선택 평문 공격
    - 공격자가 많은 수의 평문을 암호문으로 만들 수 있는 상태(단, 암호 알고리즘이나 키에 대한 정보는 모르는 상태)에서 공격하는 유형
    -  ![image](https://user-images.githubusercontent.com/61530368/172549834-c57577aa-4297-43d6-bbe0-d137c344c8a8.png)

  - 선택 암호문 공격
    - 공격자가 임의로 선택된 암호문과 일치하는 평문으로부터 암호키를 알아내기 위해 시도하는 공격
    - 공격자가 많은 수의 암호문에 대한 평문을 확보한 상태에서 시도하는 공격 유형
    - ![image](https://user-images.githubusercontent.com/61530368/172550087-748e72d9-0da0-466d-8073-3ffe8f793e6e.png)  
## 4.3 고전 암호의 공격 방법
  - 단일치환 암호의 공격
  - Vigenere 암호의 공격
  - Hill Climbing Method
# 5 현대 블록 암호 
## 5.1 현대 블록 암호의 특징
  - 연산의 단위: 비트 단위로 수행
    - 한번에 n비트 평문 블록을 암호화/복호화
    - 평문이 n비트보다 크면 분할, 작으면 n비트가 되도록 패딩(덧붙이기)
    - 보통 n = 64, 128, 256, 512비트 등
    - 암호/복호 알고리즘은 동일한 k비트 비밀키를 사용
    - 복호 알고리즘은 암호 알고리즘의 역함수 
  - 대치와 전치
    - 현대 암호 체계는 대치(Substitution) 암호와 전치(Transposition)암호를 조합하여 동작하도록 설계
    - 특히, 현대 블록 암호는 전수조사 공격에 안전하기 위하여 대치 암호를 사용하여 설계
      - 전치 암호로만 설계하면 평문과 암호문에서 0과 1의 개수가 동일
      
## 5.2 Simplified-Data Encryption Standard (S-DES)
  - DES 개요
    - IBM에서 Lucifer System을 개선하여 개발
    - 특징
      - 64비트 블럭 암호 알고리즘
      - 56비트 키를 사용: 64비트 중 8비트는 parity check로 사용
      - 라운드 수: 16 라운드
      - 복호화는 암호화의 역순
  - S-DES
    - 개요   
      - Simplified-DES의 약자ㄹ
      - 교육용 알고리즘
      - 8비트 평문 블럭과 10비트 키를 사용
      - ![image](https://user-images.githubusercontent.com/61530368/172553263-36f0e527-83cb-454d-83e3-e5800a72ca23.png)
      - IP(initial Permutation): 초기 순열
      - 함수 fk: 각 비트별로 전치(transposition)와 치환(substitution) 연산 수행
      - SW: 각 데이터의 절반을 상호 교환하는 함수
      - IP^-1(Inverse Initial Permutation): 초기 순열의 역순인 순열 함수  
  - 암호화 과정
    - Ciphertext = IP^-1(fk2(SW(fk1(IP(Plaintext)))))
  - 복호화 과정
    - Plain = IP^-1(fk1(SW(fk2(IP(Ciphertext)))))
  - 키 생성 
    - S-DES는 10-bit Key를 사용, sub-key로써 두 개의 8-bit sub key
    - ex) P10 (1010000010) -> (1000001100)
    - ![image](https://user-images.githubusercontent.com/61530368/172554665-3a2eefc6-f6e2-482b-b1b1-61eb294aad99.png)
  - LS-1
    -  1비트 Circular Left Shift연산 : ex) 10001 -> 00011
  - 함수 fk
    - 전치와 치환연산 수행
    -   ![image](https://user-images.githubusercontent.com/61530368/172555684-aacfe83b-580d-4c7b-b99e-a8966c3347dd.png)
  - S-DES 분석
    - 전수조사(Brute force) 공격 가능
      - 10비트 키로 단지 2^10가지의 가능성이 존재하므로 전수조사 공격이 충분히 가능  

## 5.3 현대 블록 암호의 구성 요소
  - 현대 블록암호의 주요 구성 요소
    - 전치요소 (P-Box)
    - 대치요소 (S-Box)
    - 그 밖의 구성 요소들(XOR, Shift, Swap 등)
    - 위 3개를 결합하여 설계
  - P-Box
    - 문자 단위로 수행하였던 고전 전치 암호를 비트 단위로 수행
    - 세 종류의 P-Box가 존재
      - 단순(Straight) P-Box
      - 확장(Expansion) P-Box
      - 축소(Compression) P-Box
  - 단순 P-Box
    - n비트 길이의 워드를 입력 받아 n비트 길이의 출력하는 치환(permutation)함수
    - ![image](https://user-images.githubusercontent.com/61530368/172556596-0be89cf9-b6ca-443e-92dd-f97e004959ef.png)

  - 축소 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이의 워드(n > m)를 출력하는 P-Box
    - ![image](https://user-images.githubusercontent.com/61530368/172556739-099561c7-63d0-4978-815d-019175e8e943.png)
  - 확장 P-Box
    - n비트 길이의 워드를 입력 받아 m비트 길이(n < m)의 워드로 출력하는 P-Box  
    - ![image](https://user-images.githubusercontent.com/61530368/172556907-ecb2879d-9fd9-4660-b1c2-618e0001296c.png)
  - P-Box의 역함수 존재성
    - 단순 P-Box는 입력 워드와 출력 워드의 비트간의 관계가 일대일 대응이므로 역함수 존재
    - 그러나, 축소 P-Box와 확장 P-Box는 일대일 대응이 아니므로 역함수가 존재하지 않음
  - S-Box
    - S-Box는 대치 암호를 나타냄
    - S-Box는 입력과 출력의 개수가 달라도 됨
    - S-Box는 m*n 대치 단위로 정의되며, 이 때 m과 n이 반드시 같을 필요는 없음  
    - ![image](https://user-images.githubusercontent.com/61530368/172557563-6ba60ddb-b10c-465a-9ad7-6847d8d41e74.png)

## 5.4 합성 암호
  - 합성 암호란?
    - 대치, 치환, 그리고 기타의 구성요소들을 결합한 복합적인 암호 
    - 설계된 블록암호가 혼돈과 확산의 성질을 갖도록 함
  - 혼돈과 확산 
    - 혼돈 
      - 암호문과 키의 관계를 숨김
      - 암호문을 이용하여 키를 찾고자 하는 공격을 어렵게 하기 위해 키의 단일 비트가 변하면 암호문의 거의 모든 비트들이 변하게 함
      - 즉, 암호문에 키를 알아내기 어렵게 하는 성질
    - 확산
      - 암호문과 평문 사이의 관계를 숨김
      - 통계 테스트를 사용하여 암호문에 대한 평문을 찾는 공격을 어렵게 함      
      - 즉, 암호문에서 원본 메시지를 알아내기 어렵게 하는 성질
  - 라운드 (Rounds)
    - 혼돈과 확산은 S-Box와 P-Box 그리고 기타 구성 요소들을 결합하는 합성 암호를 반복적으로 사용하여 구현
    - 이 때, 반복적으로 사용되는 합성 암호를 '라운드'라 함
    - 아래는 두 라운드로 구성된 합성 암호 다이어그램
    -  ![image](https://user-images.githubusercontent.com/61530368/172861442-d5e07e42-ece0-4cca-81b6-b391b46ca68f.png)
  - 현대 암호시스템의 구성 방법
    - 실제 암호시스템에서는 혼돈과 확산의 효과를 그대화하기 위하여 더 큰 데이터 블록과 더 많은 S-Box 그리고 더 많은 라운드를 사용
    - 암호문을 더욱 난수처럼(= 유사난수) 생성되게 함
    - 암호문과 평문 사이의 관계를 더욱 알아내기 힘들게 함(확산)
    - 라운드 수의 증가는 라운드 키의 개수를 증가시킴으로써 암호문과 키의 관계를 유추하기 어렵게 함(혼돈)
  - 두 종류의 합성 암호
    - Feistel 암호: 역함수가 존재하는 구성요소와 역함수가 존재하지 않는 구성요소 모두를 사용하여 설계
      - ex) DES 
    - Non-Feistel 암호: 역함수가 존재하는 구성요소만을 사용하여 설계   
      - ex) AES
  - Feistel 암호
    - Feistel 암호 구성요소 
      - 자기 자신을 역으로 갖는 것
      - 역함수가 존재하는 것
      - 역함수가 존재하지 않는 것
      - 역이 존재하지 않은 구성요소들을 서로 결합하고, 암호 알고리즘과 복호 알고리즘에서 동일한 구성요소를 사용
    - Feistel 암호의 초기 구조
      - ![image](https://user-images.githubusercontent.com/61530368/172863074-2a2d9741-a913-42ef-bfb9-38d726fadb21.png)
      - 암호화: C1 = P1 XOR f(K)
      - 복호화: P2 = C2 XOR f(K) = P1 XOR f(K) XOR f(K) = P1  
      - Feistel 구조에서 믹서는 자기 자신을 역함수로 갖음
    - 초기 구조에 대한 향상
      - ![image](https://user-images.githubusercontent.com/61530368/172863418-5d73a0bb-4dbd-4c13-bb01-52f98423281b.png)
      - 함수의 입력을 키와 평문으로 복합적으로 구성하기 위해 평문을 두 부분으로 나눔
      - 또한, 암호 알고리즘과 복호 알고리즘은 여전히 서로 역관계
  - Non-Feistel 암호
    - 주요 특징
      - S-Box는 적절하게 동일한 입출력 개수를 가져야 함
      - 축소 혹은 확장 P-Box는 역함수가 존재하지 않기 때문에 사용 할 수 없음
      - 평문이 반씩 분할될 필요 없음
      - XOR, 역이 존재하는 2 X 2 S-Box, 역이 존재하는 단순 P-Box만을 구성요소로 이용
      - 복호화에는 라운드 키를 역순으로 이용    

# 6 블록 암호에 대한 공격 방법 
## 6.1 블록 암호에 대한 공격 방법
  - 블록 암호에 대한 공격 방법
    - 차분 분석
    - 선형 분석
  - 차분 분석
    - 알고리즘 분석
      - 먼저 암호 알고리즘을 분석
      - 특정 암호는 공격자가 키를 알지 못해도 평문의 차분과 암호문의 차분 사이의 관계를 찾을 수 있는 구조적 취약점을 갖음
    - 선택 평문 공격의 시작
      - 공격자는 공격을 위해 필요한 평문의 차분을 선택   
    - 키 값의 추축
      - 공격자는 키 값을 추측하기 위하여 선택한 특정 평문과 암호문 쌍을 찾음
  - 선형 암호분석
    - 기지 평문 공격(= 알려진 평문 공격)을 이용 
## 6.2 현대 스트림 암호  
  - 현대 스트림 암호 개요
    - 암호화와 복호화 과정에서, r비트를 생성
    - 평문 비트 스트림 P = pn ... p2 p1 -> 암호화: ci = E(ki, pi) 
    - 암호 비트 스트림 C = cn ... c2 c1 -> 복호화: pi = D(ki, ci)
    - 키 비트 스트림 K = kn ... k2 k1
    -![image](https://user-images.githubusercontent.com/61530368/172867464-411b075d-aa43-4c86-9730-5b9e365b75ca.png)
  - 현대 스트림 암호의 특징
    - 블록 암호보다 속도가 빠름
    - 하드웨어 구현이 블록 암호보다 용이
    - 이진 스트림 단위의 암호화가 필요하고 고정된 속도로 암호화된 데이터를 전송하고자 할 때 스트림 암호가 적합함
    - 전송 도중 비트의 변조에 강인함
    - 현대 스트림 암호에서는 키 스트림 K = kn ... k2 k1를 어떻게 생성하는지가 주된 관심분야
  - 현대 스트림 암호의 종류
    - 동기식 스트림 암호(Synchronous Stream Ciphers)
  - 비동기식 스트림 암호(Nonsynchronous Stream Ciphers)
    - 키 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정됨
  - 동기식 스트림 암호
    - 키 스트림은 평문 혹은 암호문과 독립
    - 즉, 키는 평문/암호문과 어떤 관계도 없이 생성되고 사용됨
    - 동기식 스트림 암호의 종류
      - 일회용 키패드
      - 귀환 이동 레지스터
  - 일회용 패드(One - time pad)
    - 가장 간단하고 안전한 동기식 스트림 암호
    - 그러나 실제적으로 사용되기에는 매우 어려움 
      - 송신자가 수신자에게 키 스트림을 전달할 수 있는 안전한 채널이 존재해야 하므로, 현실적으로 구현이 불가능
      - ![image](https://user-images.githubusercontent.com/61530368/172868322-46dcf0af-1ca6-4ae4-b99e-c6b9d89490c1.png)
  - 비동기식 스트림 암호
    - 비동기식 스트림 암호에서 키 스트림의 각 비트는 이전의 평문이나 암호문에 종속되어 결정됨   
# 7 비대칭 키 암호의 기본 개념
## 7.1 소수와 나머지 정리 요약
  - 양의 정수의 3가지 종류:1, 소수, 합성수
    - 자기 자신만을 소수로 약수로 갖는 수 -> 1
    - 1과 자기 자신만을 약수로 갖는 수 -> 소수 (Primes)
    - 3개 이상의 약수를 갖는 수 -> 합성수 (Composites)
  - 서로소
    - 두 정수 a, b에 대하여 1이외에 공약수가 존재하지 않는 경우 
  - 소인수분해
    - 1보다 큰 자연수를 소인수(=소인수 인수)들만의 곱으로 나타내는 것 

## 7.2 비대칭 키 암호 시스템 특징
  - 비대칭 키 암호시스템에서는 두 개의 서로 다른 키를 사용
    - 공개키: 누구에게나 공개가 가능한 키
    - 비밀키: 자신만이 갖고 있는 키
  - 공개키로 암호화하는 경우
    - 송신자가 공개키로 평문을 암호화한 후 수신자에게 전송
    - 수신자는 자신이 갖고 있는 개인키를 이용하여 수신된 암호문을 복호화
    - ex) 공개키 암호 알고리즘 (RSA, Rabin...)
    - ![image](https://user-images.githubusercontent.com/61530368/172885867-98aa51d0-ac48-4d00-9d17-6ac30b712660.png)

  - 개인키로 암호화하는 경우
    - 송신자는 자신이 갖고 있는 개인키를 활용하여 평문을 암호화
    - 수신자에게 공개키와 함께 전달 
    - 이때, 수신자는 공개키를 이용하여 암호문을 복호화
    - 이 방법은 데이터의 보안보다는 데이터를 전송하는 송신자의 신원을 보장하는 데 더 큰 의의가 있음
      - 암문을 공개키로 복호화 -> 공개키와 쌍을 이루는 비밀키로 암호화되어었음을 의미 -> 이 비밀키는 오직 송신자만 갖고 있는 것 -> 송신자의 신원이 확실하게 보장됨을 의미
    - ex) 전자 서명    
    - ![image](https://user-images.githubusercontent.com/61530368/172885915-6b5a290a-6952-4183-8db0-9482350bc2c3.png)
  - 비대칭키 암호의 일반적인 아이디어 
    - ![image](https://user-images.githubusercontent.com/61530368/172886046-0baff05b-a951-49bf-9c43-d44c48206cea.png)
    - 대칭 키 암호시스템과는 다르게, 비대칭 키 암호시스템에서는 평문이나 암호문이 정수로 다뤄짐
  - 트랩도어 일방향 함수(Trapdoor One-Way Function)
    - 비대칭 키 암호시스템을 구성하는 핵심 아이디어 중 하나
    - 일방향 함수(One-Way Function (OWF))
      - 함수 f는 계산이 쉬운 반면에, 역함수 f^-1d는 계산이 어렵다 
      - ![image](https://user-images.githubusercontent.com/61530368/172886918-91fad376-f7a3-408e-af4f-50dce6b55ca4.png)

    - 트랩도어 일방향 함수란 ?
      - 보통 일방향함수처럼 함수의 역을 구하는 것은 어렵지만, 트랩도어라고 부르는 특수한 비밀정보가 있으면 쉽게 역을 구할 수 있는 함수
      - 어떤 비밀 값 t에 대해서, x에 대한 t가 없을 때는 f로부터 x를 구하기 어렵지만, t가 주어졌을 때 f에서 x값을 쉽게 찾을 수 있다면, 함수 f는 트랩도어 함수이다
      - ![image](https://user-images.githubusercontent.com/61530368/172887435-318e07cf-c040-4c15-8b8a-5ec90a3d0f0d.png)
      - ex1) n이 매우 큰 수라고 가정. 이 경우, n = p * q는 일방향 함수. 이때, 주어진 p와 q로부터 n을 계산하는 것은 매우 쉽다. 하지만 주어진 n으로부터 p와 q를 계산하는 것은 매우 어렵다 -> 소인수분해 문제 
      - ex2) n이 매우 큰 수라면, 함수 y = x^k mod n은 트랩도어 일방향 함수임. 이 때, x,k,n으로부터 y를 계산하는 것은 쉬움. 하지만 y,k,n이 주어졌을 때, x를 계산하는 것은 매우 어려움 -> 이산대수 문제  

## 7.3 배낭 암호
  - 최초의 공개 키 암호 시스템 아이디어
  - 현재 사용하는 공개키 암호 시스템을 구성하는 아이디어의 토대
  - 배낭 암호의 기본 원리
    - 사전에 정해진 수의 집합에서 선택된 임의의 원소들 중 어떤 것들이 배낭속에 들어있는지를 알려준다면 우리는 이 수들의 합을 쉽게 계산할 수 있음
    - 그러나, 합의 결과만 알고 있는 경우에는 그 배낭속에 들어 있는 수들이 무엇인지 알아내기는 것은 어려움 
  - 2개의 k-순서짝 a = [a1, ..., ak]와, x = [x1, ..., xk]가 주어졌을 때, 배낭 암호는 다음과 같이 정의
    - s = knapsackSum(a,x) = x1a1 + x2a2 + ... + xk*ak
    - 주어진 a와 x로부터 s를 계산하는 것은 이지 
    - but s와 a가 주어졌을 때, x를 구하는 것은 하드
    - 즉, s = kanpsackSum(a, x)는 쉽게 계산할 수 있지만, x = inv_knapsackSum(s, a)을 계산하는 것은 하드
    - 함수 knapsackSum(a, x)은 a가 일반적인 k-순서짝일 경우 하나의 일방향 함수이다 
  - 초증가 순서짝(Superincreasing Tuple)
    - a의 첫번째 원소 a1를 제외한 임의의 원소 ai가 ai >= a1 + a2 + ... + ai-1를 만족한다면, a는 "초증가 순서짝"이다 
    - 즉, 집합 a의 원소 a1을 제외한 각각의 원소가 그 이전의 모든 원소의 합보다 크거나 같은 경우
  - 초증가 순서쌍에 대한 배낭 알고리즘과 역 알고리즘
    - ![image](https://user-images.githubusercontent.com/61530368/173092828-94169e55-5abb-481a-905e-9ab30aa19a3b.png)
  - 배낭을 이용한 비밀 통신
    - ![image](https://user-images.githubusercontent.com/61530368/173092930-2f47d232-27a8-4f33-924f-b16596340586.png)
    - 키 생성 (Key generation)
      - 초증가 k-순서짝 b = [b1, ... bk]를 만든다
      - n > b1 + b2 + ... + bk를 만족하는 모듈로 n을 선정
      - n하고 서로소이면서 1 <= r <= n-1인 임의의 정수 r을 선택
      - ti = r*bi mod n을 만족하는 임시 k-순서짝 t = [t1, t2, ..., tk]를 생성
      - k개의 원소에 대한 한 가지 치환을 하여 새로운 순서짝 a = permute(t)를 구함
      - k-순서짝 a를 공개 키로 사용하고, n, r, k-순서짝 b를 개인 키로 사용
      - ![image](https://user-images.githubusercontent.com/61530368/173094390-24d0f6e0-8a0b-4014-be3a-2e214b61c4d8.png)

    - 암호화(Encryption)
      - 송신자는 자신의 메시지를 k-순서짝 x = [x1, x2, ..., xk]로 변환시킨다.(여기서 xi는 0이거나 1이다. 순서짝 x는 평문)
      - 송신자는 knapsackSum 알고리즘을 사용해서 s계산
      - 그다음, 암호문 s를 수신자에게 보냄 
      - ![image](https://user-images.githubusercontent.com/61530368/173094421-28035b11-1c39-4c3e-a96f-a1dede298844.png)

    - 복호화(Decryption)
      - 수신자는 s' = r^-1 * s mod n을 계산
      - 수신자는 inv_knapsackSum을 사용하여 x'을 계산
      - x'을 치환하여 x를 구함. 순서짝 x는 복호화된 평문
      - ![image](https://user-images.githubusercontent.com/61530368/173094570-d32f080f-0124-4f52-8b24-816184fe9cf3.png)
    - 트랩도어(1/2)
      - 송신자의 배낭에 들어있는 원소의 합을 계산하는 것은 것이 궁극적으로는 행벡터 x와 열 벡터 a와의 행렬 곱
      - 그 결과는 1x1 행렬인 s 
      - 행 벡터 x와 열 벡터 a와의 행렬 곱인 s = x * a는 일방향 함수
      - 주어진 s와 x로부터 공격자는 a를 쉽게 구할 수 없다
    - 트랩도어(2/2)
      - 한편, 수신자는 트랩도어를 가지고 있다
      - 즉, 수신자는 자신의 s' = r^-1 * s와 비밀 초증가 열 벡터인 b를 inv_knapsackSum에 입력하여 행 벡터인 x'를 구할 수 있다
      - 결과적으로, 치환을 하게 되면 수신자는 x'으로부터 x를 구할 수 있다
  - 배낭을 이용한 통신 예제 (시험에 나옴)
    - 키생성
      - 수신자는 초증가 순서짝 b = [7, 11, 19, 39, 79, 157, 313]을 만든다
      - 수신자는 모듈로로 n = 900, r = 37을 선택 (치환표로는 [4 2 5 3 1 7 6]을 선택)
      - 수신자는 순서짝 a = permute(t) = [543, 407, 223, 703, 259, 409]을 계산
      - 수신자는 순서짝 t = [259, 407, 703, 259, 781, 409]를 계산
      - 수신자는 a를 공개. 그리고 n, r, b는 비밀로 한다
    - 송신자가 단 하나의 문자 "g"만을 수시낮에게 보낸다고 가정 
      - 송신자는 7비트 ASCII코드를 이용하여 "g"를 (1100111)2로 부호화
      - 그 다음 순서짝 x = [1, 1, 0, 1, 1, 1]을 생성. 이것이 평문
      - 송신자는 s=knapsackSum(a, x) = 2165를 생성. 이것이 수신자에게 보낼 암호문
    - 수신자는 암호문 s = 2165를 복호화
      - 수신자는 s' = x * r^-1 mod n = 2165 * 37^-1 mod 900 = 527을 계산
      - 수신자는 x' = inv_knapsackSum(a', b) = [1, 1, 0, 1, 0, 1, 1]를 계산
      - 수신자는 x = permute(x') = [1, 1, 0, 0, 1, ,1 , 1]을 계산하여 (1100111)2를 얻음
      - 이것을 ASCII 코드를 이용하여 문자로 환원하면 문자 "g"를 얻음 
## 7.4 RSA 암호시스템
  - 개요
    - RSA: 개발자 3명의 이름을 따서 만듦
    - 가장 많이 사용되는 공개 키 알고리즘
    - RSA는 모듈로 지수연산을 이용하여 암호화/복호화를 한다
    - 이것을 공격하려면 공격자는 C^(1/e) mod n을 계산해야한다(지수 복잡도이며 공격이 매우 하드)
    - ![image](https://user-images.githubusercontent.com/61530368/173098854-dbd91c66-b42c-427f-9742-956179db7141.png)
  - 키 생성
    - 군 G에서 공개키와 비밀키를 생성
    - ![image](https://user-images.githubusercontent.com/61530368/173100098-6b8f8663-f8f1-4ba7-b84b-85af4861d462.png)
    - 수신자는 순서쌍(e, n)을 공개키로, d를 비밀키로 설정
    - p, q와 O(n)을 버림 
    - 이 때, 안전을 위해 권장되는 p와 q의 크기는 512비트

  - 암호화
    - 환 R에서 공개키 (e, n)을 사용하여 평문을 암호화
    - C ≡ P^e mod n 
    - where (e,n):공개키
    - ![image](https://user-images.githubusercontent.com/61530368/173100273-ee4bd4a6-c11e-4038-b882-c98a736e5eb3.png)
    - 공개키 (e, n)을 사용하여 수신자에게 메시지를 보낼 수 있음
    - 다항식 연산 정도의 복잡도를 가진 알고리즘을 이용해서 수행
    - 평문의 크기는 n의 길이보다 작아야 하며, 만약 평문 길이가 n보다 크다면, 평문을 n보다 작은 블록으로 나누어 암호화함
   

  - 복호화
    - 환 R에서 비밀키 d를 이용하여 암호문을 복호화   
    - P ≡ C^d mod n
    - where d: 비밀키
    - ![image](https://user-images.githubusercontent.com/61530368/173100449-dcee1990-1e68-49df-ae66-b78f5c402d3f.png)
    - 암호화와 마찬가지로 다항식 연산 정도의 복잡도로 계산
    - 이 때 암호문의 크기는 n보다 작음
- RSA 암호화/복호화 예제
  - 수신자는 p와 q를 7과 11로 선택해서 n = 7*11 = 77을 계산
  - 그렇다면 O(n) = (7 - 1) * (11 -1) = 60
  - 수신자는 Z^(*)60내에서 두 개의 지수 e와 d를 선택
  - 이 때, 만약 e = 13이면 d = 37이 된다(e * d mod 60 = 1)
  - ![image](https://user-images.githubusercontent.com/61530368/173101255-85e5039b-13df-4f45-b5fb-1b6761a13b22.png)
  - 이제 송신자가 평문 5를 수신자에게 보낸다고 가정
  - 이 경우, 송신자는 공개된 값 e = 13을 이용해서 5를 다음과 같이 암호화
    - 평문: 5, C = 5^13 mod 77 = 26
  - 수신자는 암호문 26을 수신하게 되며 자신의 개인키 d = 37을 이용하여 이 암호문을 다음과 같이 복호화
    - 암호문: 26, P = 26^37 mod 77   

## 7.5 Rabiin 암호시스템 
  - 개요
    - Rabin 암호시스템은 e와 d가 고정된 값을 갖는 RSA 암호시스템
      - e = 2, d = 1/2
      - 암호화 C ≡ P^2 mod n
      - 복호화 P ≡ C^(1/2) mod n
    - 공개키: n
    - 비밀키: 순서쌍(p, q)
    - 즉, 누구나 n을 이용하여 평문을 암호화 할 수 있고, 수신자는 자신이 갖고 있는 비밀키(p,q)를 활용하여 복호화 할 수 있음
    - 복호화 시 RSA와 Rabin의 차이점
       - RSA: 수신자는 d와 n을 간직하고 키를 생성한 다음 p, q, O(n)을 버림
       - Rabin: 수신자는 p와 q값을 반드시 갖고 있어야함 
    - ![image](https://user-images.githubusercontent.com/61530368/173101987-649d73c1-ad63-4e3a-b265-c6a5f82361b8.png)
  - 키 생성
    - ![image](https://user-images.githubusercontent.com/61530368/173103468-fc4f34c3-6097-41f7-b83f-8016a6b1d6be.png)
    - 두 소수 p와 q는 4k+1 또는 4k+3의 형식 모두 가능하지만, 4k+1의 형식일 경우 복호화 과정이 어려워짐
    - 따라서, 수신자가 쉽게 복호화를 할 수 있또록 4k+3의 형식으로 두 소수 p와 q를 선택
  - 암호화(Encrytion)
    - ![image](https://user-images.githubusercontent.com/61530368/173103849-71d5ccdd-ae3b-46c7-9e66-dc8c883a9e87.png)
    - 평문 P가 Zn에 속해 있지만, 복호화를 쉽게 하기 위해 Z^(*)n으로 한정함
    - 암호화 연산은 매우 간단하여 성능이 낮은 플랫폼(e.g., 스마트카드)에서도 효과적으로 활용될 수 있음
  - 복호화(Decryption)
    - ![image](https://user-images.githubusercontent.com/61530368/173104121-4f2e60f7-7595-4e11-848d-f5c213aaefb6.png)
    - 암호문 C와 개인키 p, q를 활용하여 a1, a2, b1, b2를 계산
    - (a1, b1), (a1, b2), (a2, b1), (a2, b2) 각각에 대해, 중국인의 나머지 정리 알고리즘을 호출하여 복호화를 수행
  - Rabin 암호시스템의 특징
    - Rabin 암호시스템은 결정적 알고리즘이 아님
    - 암호화를 하면 동등한 확률로 4개의 평문 후보가 나타난다
    - 수신자는 이 4개의 평문 후보 중에서 하나의 최종 답을 선택(일반적으로 수신자는 답을 쉽게 선택할 수 있음)
    - Rabin 암호시스템은 소인수분해 문제와 동치
  - Rabin 암호화/복호화 예제
    - 수신자는 p = 23과 q = 71을 선택 
    - 이 두수는 모듈로 4로서, 3과 합동
    - 이후, 수신자는 n = p*q = 161을 계산
    - 수신자는 n을 공개한다. 반면에 p와 q는 비밀로 유지
    - 송신자가 평문 P=24를 수신자에게 보내고자 한다. 이때, 161과 24는 서로소이며, 24는 Z^(*)161의 원소이다. 
    - 송신자는 C = 24^2 mod 161을 계산하여, 그 결과인 93을 수신자에게 보냄
    - 수신자는 93을 수신하고 다음 4 개의 값을 계싼
      - a1 = +(93^((23+1)/4) mod 23 = 1 mod 23
      - a2 = -(93^((23+1)/4) mod 23 = 22 mod 23
      - b1 = +(93^((7+1)/4) mod 7 = 4 mod 7
      - b2 = -(93^((7+1)/4) mod 7 = 3 mod 7
    - 수신자는 4개의 가능한 답(a1, b1), (a1, b2), (a2, b1), (a2, b2)을 선택
    - 중국인의 나머지 정리를 사용하여 4개의 가능한 평문인 116, 24, 137, 45를 구함
    - 이 4개는 모두 161과 서로소이다. 오직 2번째 평문만이 송신자가 보낸 평문과 동일한 것  
## 소수 집합의 크기
  - 소수의 개수 
    - 무한
  - 소수의 개수의 상한과 하한
    - PI(n)은 n보다 작거나 같은 소수의 개수를 나타내는 함수
    - 이때, n이 매우 큰 값이라면 PI(n)을 어떻게 계산할 수 있는가

# Advanced Encrytion Standard (AES)
## AES 개요
  - AES에 사용되는 주요 영어와 개념
    - 라운드
      - AES는 128비트 평문을 128비트 암호문으로 출력하는 알고리즘 (Non-Feistel 알고리즘
      - 10,12,14 라운드를 사용
      - 각 라운드에 대응하는 마스터 키 크기는 128, 192, 256비트
      - 단, 라운드 키의 크기는 모두 128비트 
      - ![image](https://user-images.githubusercontent.com/61530368/174278632-8c6258ea-4fb3-403d-b901-bb3b6fc1cc42.png)
    - 데이터 단위
      - 바이트 (8비트)
      - 워드 (4바이트)
      - 블록 (4워드, 16바이트, 128비트)
      - 상태
      - ![image](https://user-images.githubusercontent.com/61530368/174278691-1b6f2457-27f7-4c67-83e4-60a11934c2f1.png)
    - 상태와 블록의 변환 방법
      - 16개의 블록을 4x4 상태 행렬로 변환 가능
      - i번째 블록이 상태 행렬에 매핑되는 공식
      - 상태 행렬의 i번째 행, j번째 열에 위치한 entry가 블록으로 매핑되는 공식
      - ![image](https://user-images.githubusercontent.com/61530368/174279000-1babbdd6-7698-429b-8889-b88c3ebab0a5.png)
    - 예제1) 주어진 평문을 상태로 변환하는 방법 
      - 평문이 "AES uses a matrix"로 주어졌다고 가정(총 14글자)
      - 먼저, 길이를 16으로 맞추기 위해, 위 텍스트 블록 마지막에 가짜 문자 "ZZ"를 추가
      - 텍스트 블록 내의 16개의 문자 각각을 00과 25사이의 정수(10진수)로 표현
      - 각 바이트를 16진수의 정수로 나타냄(예. "S" -> 18 -> 12(16진수) 
      - 상태 행렬의 각 entry를 왼쪽 문자열로 부터 한 열씩 차례로 채움
      - ![image](https://user-images.githubusercontent.com/61530368/174279361-cac17ad3-f312-4f55-9a17-9e6064e893f2.png)
  - AES의 라운드 구조
    - 입력 (input)
      - 상태 (state)  
    - 라운드 (round)
      - SubBytes 변환
      - ShiftRows 변환
      - MixColumns 변환
      - AddRoundKey 변환
    - 출력(Output)
      - 4개의 변환을 거친 상태
    - ![image](https://user-images.githubusercontent.com/61530368/174279593-4830633e-a304-4c96-97f6-0752e079be48.png)
  
## AES 변환 연산
  - AES 변환 연산
    - AES 알고리즘은 안전성을 제공하기 위해 아래와 같은 4가지 형태의 변환을 사용
      - 대치(Substitution)
      - 치환(Permutation)
      - 뒤섞음(Mixing)
      - 키-덧셈(Key-adding)
  - 대치(Substitution)
    - AES의 대치 연산은 DES에서 사용된 "대치" 연산과는 아래와 같은 측면에서 메커니즘이 다름
      - AES의 대치 변환은 각 바이트에 적용됨
      - 모든 바이트 변환을 위해 하나의 테이블만 사용함
      - 변환은 표 참조 과정 또는 GF(2^8)상의 수학적 연산으로 정의됨
      - 역연산이 가능한 두 개의 변환을 사용
    - SubBytes
      - AES 암호화 과정에서 사용하는 대치 함수
      - 각 바이트를 4비트씩 2개의 16진수로 계산한 후,
      - 오른쪽 4비트를 S-박스의 행으로 오른쪽 4비트를 열로 표를 읽음
      - 즉, 두 16진수의 행과 열이 교차하는 부분에 해당되는 바이트 값을 출력
      - AES의 128비트 상태를 한 바이트를 성분으로 갖는 4X4 행렬로 나타냄
      - 각 바이트에 독립적으로 SubBytes 함수를 수행하고, 계산 후에도 행렬에서 성분들의 위치는 변하지 않음 
      - 따라서 SubBytes 연산은 16개의 독립된 바이트 단위의 변환을 수행
      - ![image](https://user-images.githubusercontent.com/61530368/174280349-ff2c2f9a-1609-488c-9058-a6667520b00a.png)
      - SubBytes 변환을 위한 S-박스 대치 표(substitution table) -> 혼돈(confusion) 효과 유발 
      - ex) 두 개의 바이트 5A(16비트)과 5B(16비트) (단지 1개의 비트만 다르지만, S-박스에 의해 BE(16비트)과 39(16비트)으로 변환되어 총 4개의 비트가 달라짐
      - ![image](https://user-images.githubusercontent.com/61530368/174280589-1324777b-e875-42d5-b466-74f2a395b474.png)
    - InSubBytes
      - SubBytes의 역변환
      - InvSubBytes의 S-박스 대치표는 앞서 설명한 SubBytes의 대치 표와 역변환 관계임
      - 즉, SubBytes 변환과 InvSubBytes 변환은 서로 역변환 관계임이 성립
    - 예제 2) 두 개의 바이트가 동일한 값을 가지면 변환 후의 값 역시 동일
      - ![image](https://user-images.githubusercontent.com/61530368/174281152-997d6121-9db9-4f07-a223-0f6a1a2c093a.png)
    - GF(2^8)를 이용한 변환 방법
      - AES는 기약 다항식 x^8 + x^4 + x^3 + x + 1을 갖는 체 GF(2^8)을 이용하여 대수적인 변환으로 S-박스를 정의함
      - SubBytes 변환: subbyte 루틴을 16번 반복
        - ![image](https://user-images.githubusercontent.com/61530368/174281324-eae1ff37-74e0-4b5d-a635-160b98192d1a.png)
      - InvSubBytes 변환: invsubbyte 루틴을 16번 반족
        - ![image](https://user-images.githubusercontent.com/61530368/174281390-1ca0fcb0-474d-4b30-9b4e-0edd5c872ddd.png)
      - 이 때 각 루틴은 한 바이트씩 처리 
    - SubBytes와 InvSubBytes 과정
      - SubBytes 변환
        - ![image](https://user-images.githubusercontent.com/61530368/174281705-de9cbbe8-3265-48f4-87c9-8e609a6ff872.png)
        - ![image](https://user-images.githubusercontent.com/61530368/174281621-a54c498c-7fa2-4fd4-b70f-17da1f1a520b.png)
      - InvSubBytes 변환
        - ![image](https://user-images.githubusercontent.com/61530368/174281737-f2bc58ea-94ff-48b1-9267-0c4010b6e3ab.png)
        - ![image](https://user-images.githubusercontent.com/61530368/174281676-252900d7-f2e6-4fe0-acf9-476a690ecd97.png)
    - 예제 3) 16진수 0C(16)을 subbyte를 통해 FE(16)으로 계산하는 과정을 보이고 역으로 invsubbyte를 통해 다시 0C(16)으로 계산하는 과정은 다움과 같다 
      - subbyte routine
        - GF(2^8)체에서 0C(16)의 곱셈에 대한 역원은 B0(16)이고, 이것을 비트 단위로 표현하면 b=(10110000)이다.
        - 행렬 X와 곱셈 연산 후 값은 c=(10011101)이 된다
        - XOR 연산 후의 값은 d=(11111110)이 되며, 이는 FE(16)의 비트 단위 표현이다
      - invsubbyte routine
        - XOR연산 후의 값은 c=(10011101)이다
        - 행렬 X^-1를 곱한 이후의 값은 (10110000) 또는 B0(16)이 된다
        - B0의 곱셈에 대한 역원은 0C16이    
    - 비선형성
      - subbyte routine의 행렬 단위 덧셈과 곱셈은 아핀-형 변환(affine-type transformation) 연산으로 선형임
      - 그러나 각 비트를 체 GF(2^8)에서 곱셈에 대한 역원으로 대체하는 것은 비선형 연산임
      - 따라서 이는 전체 변환을 비선형으로 바꾸는 역할을 함  
  - 치환(Permutation)
    - 치환이란?
      - AES의 라운드에서 사용하는 또 다른 변환 -> 이동 변환(shifting)
      - 이 때 이동 변환은 바이트 단위의 치환이다
      - AES에서 이동 변환은 바이트 단위로 이루어지므로, 한 바이트 내에서의 순서는 변하지 않는다
        - 반면에 DES의 경우, 비트 단위로 이동(shifting)을 수행하므로, 순서가 변함
      - AES 이동 변환의 종류
        - ShiftRows
        - InvShiftRows
    - ShiftsRows/InvShiftRows -> 서로 역변환 관계
      - ShiftRows는 암호화 과정에서 사용되며 왼쪽으로 이동을 수행
      - 이 때 이동하는 횟수는 상태 행렬의 행 번호(0~3)에 따라 결정되며 한 번에 하나의 행을 변환함
      - InvShiftRows는 복호화 과정에서 사용하고 오른쪽으로 이동을 수행함. 이 때 이동 수는 상태 행렬의 행 번호(0~3)에 따라 결정됨 
      - ![image](https://user-images.githubusercontent.com/61530368/174285017-589a90ec-3032-4c09-a408-321496a938aa.png)
    - 예제 4) 다음 그림은 하나의 상태가 ShiftRows와 InvShiftRows 변환에 의해서 어떻게 치환되는가를 보여준다
      - ![image](https://user-images.githubusercontent.com/61530368/174285164-381fb479-af8f-43ac-b0af-a7ae7f073ded.png)
  - 뒤섞음(Mixing)
    - SubBytes 변환과 ShiftRows 변환
      - SubBytes 변환: 하나의 바이트 내 변환(intrabyte transformation)
      - ShiftRows 변환: 바이트 자체를 교환(byte-exchange transformation)
    - 바이트 뒤섞음의 필요성
      - 그렇다면, 인접한 바이트 안에 있는 비트들에 기반하여 비트 값을 바꾸는 바이트 내 변환이 필요
      - 즉, 비트 단위의 확산(diffusion)을 줄 수 있는 바이트 뒤섞음이 필요 
    - 뒤섞음 연산의 개념
      - 한 번에 네 개의 바이트를 가지고 각 바이트의 비트들을 바꾸어서 네 개의 새로운 바이트를 생성하기 위해 이들을 결합
      - 먼저, 각 바이트에 서로 다른 상수 값을 곱해서 이들을 뒤섞음
        - 네 개의 입력 바이트가 동일해도 결합 과정은 새로운 바이트가 각각 서로 다르다는 것을 보장함
      - 이 때 뒤섞음 연산은 행렬 곱 연산에 의해 수행
        - 전방행렬 X열 행렬 = 새로운 열 행렬
        - 새로운 행렬의 각 원소는 상수 행렬에서 행들의 원소에 의해 곱해진 후 이전 행렬의 네 개의 모든 원소에 의존하게 됨  
        - ![image](https://user-images.githubusercontent.com/61530368/174285878-af56c432-2fe1-41ab-bc3c-de16b9dbb87d.png)
    - MixColumns
      - 열 단위 연산 수행 -> 각 상태의 열을 새로운 열로 변환
      - 상태 열 행렬에 상수 정방 행렬을 곱하는 연산 
      - 상태 열 행렬과 상수 행렬의 각 바이트는 GF(2) 원소를 계수로 갖는 8비트 워드(or 다항식)으로 해석
      - 이 때, 바이트의 곱셈은 모듈로(10001101)을 가지고 GF(2^8)에서 행해지고, 덧셈은 8비트 워드의 XOR 연산과 동일 
      - ![image](https://user-images.githubusercontent.com/61530368/174286116-3ca35005-0e03-4c2a-897c-e3547ba25842.png)
    - InvMixColumns
      - MixColumns 변환과 동일함
      - 두 상수 행렬은 서로 역 행렬이므로, "MixColumns 변환과 InvMixColumns 변환은 서로 역변환 관계"  
    - 예제 5) 아래의 그림은 하나의 상태가 MixColumns 변환을 어떻게 이용하여 변환될 수 있는가, 그리고 InvMixColumns 변환을 통해 원래 값으로 복원하는가를 보여준다
      - ![image](https://user-images.githubusercontent.com/61530368/174287053-ef7601d6-081a-4512-8531-1fa8b83867f2.png)
  - 키-덧셈(Key-adding)
    - addRoundKey
      - 한 번에 한 열씩 수행하는 연산(MixColumns와 유사)
      - 그러나, MixColumns와 달리 AddRoundKey는 각 상태 열 행렬에 라운드 키 워드를 더함(MixColumns -> 행렬 곱셈 연산 사용)
      - 이 체 위에서는 덧셈과 뺄셈 연산이 동일하므로(XOR), AddRoundKey 변환은 자기 자신이 역변환이 됨  
      - ![image](https://user-images.githubusercontent.com/61530368/174287263-5a01e494-a480-42da-b3fa-e7d94b675d06.png)


## 키 확장
  - 키 확장(key expansion)의 기본 개념
    - 각 라운드에 사용할 라운드 키를 생성하기 위해 사용되는 기능
    - 라운드의 수를 Nr이라 표기할 때, 키 확장 과정을 통해 하나의 128비트 암호 키로부터 Nr+1개의 128비트 라운드 키를 생성
    - 처음 생성한 라운드 키는 알고리즘 시작 전, 평문과 XOR 하고(-> AddRoundKey) 나머지 라운드 키들은 각 라운드의 마지막 단계에서 XOR 연산을 수행
    - 워드가 4개의 바이트로 이루어질 때, 키 확장 루틴은 워드 단위로 라운드 키를 생성하며, 이 때 루틴은 4x(Nr+1) 길이의 워드를 아래와 같이 생성
      - ![image](https://user-images.githubusercontent.com/61530368/174288553-deb67963-0486-4b3e-b1a1-558af092451e.png)
    - 구성 라운드 수에 따른  필요 워드의 수
      - 10 라운드로 구성된 AES-128의 경우 -> 44개의 워드
      - 12 라운드로 구성된 AES-192의 경우 -> 52개의 워드
      - 14 라운드로 구성된 AES-256의 경우 -> 60개의 워드 
      - ![image](https://user-images.githubusercontent.com/61530368/174289018-40f97998-f8c8-43e9-a52e-f9de690a8aa4.png)
  - AES-128에서의 키 확장
    - 처음 4개의 워드 w0, w1, w2, w3은 암호 키로부터 생성되며, 이 때 암호 키를 16개의 바이트 k0부터 k15까지로 구성된 배열로 간주함 
    - 처음 4개의 바이트(k0~k3)는 w0가 되고 그런 다음 4개의 바이트(k4~k7)는 w1이 되며, 나머지 바이트도 동일하게 정의됨
    - 즉, 암호 키는 w0, w1, w2, w3를 하나로 연결한 것 
    - 나머지 워드(wi, 4 <= i <= 43)에서의 계산 방법
      - i mod 4 != 0일 경우, wi = wi-1 XOR wi-4로 계산함. 즉, 각 워드를 생성할 때, 왼쪽에서 하나, 위쪽에서 하나를 가지고 만드는 과정임
      - i mod 4 = 0일 경우, wi = t XOR wi-4로 계산함. 이 때 t는 두개의 루틴 SubWord와 RotWord, 라운드 상수 Rcon을 사용하여 아래와 같이 계산됨
        - t = SubWord(RotWord(wi-1) XOR RConi/4 
    - ![image](https://user-images.githubusercontent.com/61530368/174316506-e3d70c5c-f8d4-4476-b825-2922ceafaace.png)
    - RotWord
      - 워드를 순환 이동시키는 루틴
      - ShiftRows 변환과 유사하지만, ShiftRows와 달리 하나의 열에만 적용
      - 4개의 바이트로 구성된 하나의 워드를 입력으로, 왼쪽으로 한 바이트씩 이동시킴
    - SubWord
      - SubBytes변환과 유사하지만, 단지 4개의 바이트에만 적용됨
      - 워드의 각 바이트를 S-박스를 이용하여 대치한 후 출력
    - 라운드 상수
      - 4바이트 값으로 가장 오른쪽의 3바이트는 모두 0
      - 10라운드로 구성된 AES-128의 각 라운드에서 사용하는 상수값   
    
## AES 암호
  - AES 암호와 역암호의 기본 설계
    - AES 암호 알고리즘 -> 암호(Cipher)
    - AES 복호 알고리즘 -> 역암호(Inverse cipher)
    - AES는 Non-Feistel 암호
      - 각 변환 또는 변환들의 군은 자신의 역변환을 갖는다
      - 암호와 역암호는 이 연산들이 서로 상쇄되는 방식으로 사용됨
      - 라운드 키 역시 역순서로 사용 
    - 특징
      - 역암호에서 SubBytes와 ShiftRows의 순서가 바뀐다
      - 역암호에서 MixColumns와 AddRoundKey의 순서가 바뀐다
        - 이와 같은 순서의 차이는 암호에서 각 변환을 역암호에서 자신의 역변환과 동일하게 대응하기 위해서 필요
        - 따라서 복호 알고리즘은 암호 알고리즘의 역함수 
    - ![image](https://user-images.githubusercontent.com/61530368/174318934-79769bb3-06d0-43aa-bfdd-e075996ef444.png)
    - AES-128에의 기본 설계에 대한 pseudocode
      - ![image](https://user-images.githubusercontent.com/61530368/174319043-081e8831-c9b7-4ecc-85b2-cc436be841ae.png)
    - SubBytes와 ShiftRows 조합의 가역성(Invertibility)
      - SubBytes는 상태 값에서 바이트의 순서를 변경하지 않고 각 바이트의 값을 변경
      - 반면에 ShiftRows는 바이트 값을 변경하지 않고 순서만 변경
      - 이는 역암호에서 전체 알고리즘의 가역성을 유지함과 동시에 이 두 변환의 순서를 바꿀 수 있음을 의미
      - ![image](https://user-images.githubusercontent.com/61530368/174319335-7e554129-bf27-476d-b1e1-e849fe634b46.png)
    - MixColumns와 AddRoundKey 조합의 가역성
      - MixColumns에서 사용된 상수 행렬의 역행렬을 키 행렬에 곱하는 경우, MixColumns와 AddRoundKey는 서로 역함수 관계
      - ![image](https://user-images.githubusercontent.com/61530368/174319476-5011d43a-f966-464b-893e-82e8d87de50e.png)
    - 대체 설계에서의 암호와 역암호 
      - ![image](https://user-images.githubusercontent.com/61530368/174319723-257eef79-4325-46e2-926c-1393380fb0f6.png)
    - 키 확장 알고리즘의 변경
      - 역암호에서 InvRoundKey 대신, 다른 라운드 키 집합을 생성하도록 키 확장 알고리즘을 변경할 수 있음
      - 그러나 pre-round에 대한 라운드 키와 마지막 라운드에 대한 라운드 키는 수정되지 않아야 함  
## AES 분석
  - AES의 보안성
    - AES는 DES가 설계된 후에 설계됨. 따라서 DES에 대한 알려진 대부분의 공격들이 이미 AES에 적용됨
      - Brute-Force Attack: AES는 DES보다 큰 사이즈의 키(비트)를 사용하기 때문에 DES보다 더 안전
      - Statistical Attacks: 수많은 테스트들이 암호문의 통계적인 분석에 실패
      - Differential and Linear Attacks: 아직까지 AES에 대한 차분 공격과 선형 공격이 알려지지 않음 
  - AES의 구현 
    - AES의 구현
      - AES는 소프트웨어, 하드웨어, 펌웨어로 구현할 수 있음
      - 특히, Table lookup 또는 잘 정의된 대수적 구조를 사용하는 루틴을 사용하여 구현될 수 있음
    - AES의 단순성과 비용
      - AES에 사용하는 알고리즘은 매우 단순하므로 저렴한 프로세서와 최소메모리를 이용하여 쉽게 구현 가능 
    

# 현대 블록 암호의 모드 & 스트림 암호의 사용
## 현대블록 암호의 사용
  - 개요
    - 블록 암호
      - 블록 단위로 데이터를 암호화 또는 복호화
      - ex) DES: 64bit, AES: 128/192/256bit
    - 운영 모드
      - 실제 환경에서 임의의 길이의 데이터를 블록 단위로 암호화하는 방법
      - ![image](https://user-images.githubusercontent.com/61530368/174323616-9c433bb5-dab8-42ff-bda3-e9dae7cd7aa3.png)
  - ECB 모드
    - ECB(Electronic Codebook)
      - 가장 간단한 모드로 평문을 N개의 n비트 블록으로 분할
      - 평문 크기가 블록 크기의 배수가 아니면 패딩(padding)연산 수행
      - 각 블록을 독립된 것으로 하여 개별적으로 암호화하고 복호화하는 방법
      - 암호화: Ci = Ek(Pi), 복호화: Pi = Dk(Ci)
      - ![image](https://user-images.githubusercontent.com/61530368/174323845-2e8f78c5-fe62-4d0f-9295-a8c0c795c1dc.png)
    - 예제1)
      - 수신자는 송신자가 암호화한 평문 블록을 정확하게 복구할 수 있다. 왜냐하면 암호화와 복호화는 아래와 같이 서로 역관계에 있기 때문
      - ![image](https://user-images.githubusercontent.com/61530368/174324234-fa26c897-eb44-4286-912b-150c4fc5d73e.png)
    - 예제2)
      - ECB모드는 두 개의 열에 2^n개의 성분을 갖는 2^k개의 코드북을 사전 수집할 수 있으므로 Electronic codebook으로 불린다. 각각의 성분은 평문과 그에 대응하는 암호문으로 목록화 할 수 있다
    - 오류파급(Error Propagation)
      - 전송 도중에 발생하는 단일 비트의 에러는 대응되는 블록 내의 비트들에만 에러를 발생시킴 
    - ECB 모드 알고리즘   
      - ![image](https://user-images.githubusercontent.com/61530368/174324509-3cd2a54f-d3b0-42e5-9041-63498c4bad8f.png)
    - ECB 모드의 응용
      - 안전하지 않은 채널을 통하여 두 개 이상의 블록을 갖는 메시지를 암호화하여 전송하는 수단으로 적당하지 않음
      - 메시지 크기가 한 블록 이하라면 안전성 및 오류 파급은 문제가 되지 않음 
      - 한편, 데이터베이스에 암호화된 레코드를 저장하거나 암호화된 레코드를 복호화할 때는 아래와 같은 특성으로 인하여 암호문 블록의 독립성이 유용
        - 데이터베이스에 랜덤하게 접근 가능
        - 다른 레코드에 영향을 주지 않고 중간 레코드 수정 가능
        - 큰 데이터베이스를 암호화할 때 병렬적으로 처리 가능
  - CBC 모드
    - Cipher Block Chaining(CBC)모드
      - 각각의 평문 블록은 암호화되기 전에 이전 블록의 암호문과 XOR됨
      - 이 때 암호문은 다음 블록을 암호화할 때 사용하기 위해 메모리에 저장됨
      - 첫 블록을 암호화 할 때는 초기벡터(IV)를 사용
      - CBC모드에서 암호화 및 복호화 방법 
      - ![image](https://user-images.githubusercontent.com/61530368/174325249-c54a0fc8-07d3-473f-88c6-231fd0820f91.png)
    - 예제3) 
      - 송신자가 암호화한 평문 블록을 수신자는 정확하게 복구할 수 있다. 왜냐하면 CBC모드에서 암호화와 복호화 과정은 아래와 같이 서로 역관계 이기 때문 
      - ![image](https://user-images.githubusercontent.com/61530368/174325382-e5bc9290-1fef-4bfc-b055-a5d5a2cd1df7.png)
    - 초기벡터(IV)
      - 송신자와 수신자간에 공유되어야 하지만 반드시 비밀일 필요는 없음
      - 단, 변조되어서는 안됨
      - 따라서, 송신자가 임의의 난수를 선택한 후 이를 수신자에게 전송하는 방법이 효과적    
    - 오류 파급
      - 암호문 블록 Cj가 전송 도중 한 비트 오류가 발생하였다고 가정하자.  
      - 이 때, 복호화 과정에서는 평문 블록 Pj에서는 대부분의 비트에서 요류가 발생되며, 평문 블록 Pj+1에서는 Cj의 오류 비트와 같은 위치에서 한 비트 오류가 발생
      - 그러나 Pj+2부터 Pn까지의 평문 블록은 이러한 한 비트 에러에 영향을 받지 않음
      - 그러므로 암호문의 한 비트 에러는 자기 복구가 이루어짐
    - CBC 모드 알고리즘
      - ![image](https://user-images.githubusercontent.com/61530368/174326869-1c8d57de-ec23-4e89-a65c-935d7356371d.png)
  - CFB모드
    - Ciphper Feedback(CFB)모드
      - 크기가 r(<=n)인 블록 단위로 암호화 및 복호화를 수행
      - 블록암호를 사용하여 평문을 직접적으로 암호화하지 않음
      - ![image](https://user-images.githubusercontent.com/61530368/174327010-4618ef05-464d-40e7-9876-4bea439fc3d6.png)
    - 평문 블록과 암호문 블록 사이의 관계
      - 암호화:![image](https://user-images.githubusercontent.com/61530368/174327067-6424f682-cb2c-48b2-baa0-d6d387486d2f.png)
      - 복호화:![image](https://user-images.githubusercontent.com/61530368/174327090-013670c2-f46b-4164-8534-de1da1356deb.png)
      - SelectLeftr = 입력값의 왼쪽 최상위 r비트를 출력하는 함수
      - ShiftLeftr = 입력값을 왼쪽으로 r비트 이동시키는함수. 이때, 왼쪽 최상위 r비트는 shift 과정에서 손실됨
    - 스트림 암호로서의 CFB 모드
      - 블록 암호를 위한 운영 모드이지만 그 결과는 스트림 암호와 동일
      - 키 스트림이 암호문에 의존하는 비동기식 스트림 암호임 
      - ![image](https://user-images.githubusercontent.com/61530368/174327467-13c8677d-86d9-43f2-969e-b06c7233c439.png)
    - CFB모드 알고리즘
      - ![image](https://user-images.githubusercontent.com/61530368/174328105-d49644e8-28b8-4526-bf79-a36e975a438a.png)
    - 안전성
      - 블록 단위의 패턴이 유지되지 않음
      - 송신자는 메시지를 전송할 때마다 다른 IV를 사용해야 함
      - 공격자는 암호문의 끝에 특정 암호문 블록을 덧붙일 수 있음
    - 오류 파급
      - 전송 도중 암호문에 한 비트 오류가 발생하면, 복호화 시에 평문의 같은 비트 위치에서 한 비트 오류가 발생
      - 그러나, 다음 평문 블록에서는 대부분의 비트에서 오류가 발생  
  - OFB 모드 
    - Output Feedback(OFB)모드
      - 암호문 블록의 각 비트는 이전 암호문 비트들과 독립적임
      - 전송 중 오류가 발생해도 다음 블록 비트에 영향주지 않음
      - ![image](https://user-images.githubusercontent.com/61530368/174328635-a5f667dd-a785-4735-99b2-4ee5286c42ac.png)
    - 스트림 암호로서의 OFB모드
      - CFB와 같이 블록암호를 기반으로 한 스트림 암호
      - 키 스트림은 평문/암호문과는 독립인 동기식 스트림 암호
      - ![image](https://user-images.githubusercontent.com/61530368/174328767-ae3ef8c0-287a-4542-b6c8-5e81f98fd768.png)
    - OFB 모드 알고리즘
      - ![image](https://user-images.githubusercontent.com/61530368/174328821-0e56a1d2-e128-41d2-a433-7a52b2210956.png)
    - 안전성
      - 블록 단위의 패턴이 유지되지 않음
      - 암호문이 임의로 변조된다면 수신자가 복호화하는 평문에 영향을 줌
    - 오류 파급
      - 암호문의 한 비트 오류는 단지 대응되는 평문의 한 비트에만 영향을 미침 
  - CTR 모드
    - Counter(CTR)모드
      - 암호화 시 피드백이 존재하지 않음
      - 키 스트림의 의사 난수성은 카운터를 사용함으로써 성립
      - n비트 카운터는 초기 벡터(IV)값으로 초기화되고 규칙에 따라 증가
      - 블록 크기는 블록 암호(DES, AES)의 블록 크기와 동일
      - 이전 암호문 블록과 독립인 키 스트림을 생성하지만 피드백을 사용하지 않음
      - 서로 독립인 n비트 암호문 블록을 생성
      - 완전한 n비트 블록이 입력되어야 암호화를 수행 (실시간 프로세싱 환경에서 사용 제한)
      - 랜덤하게 접근한 파일을 암호화 및 복호화 할 수 있음      
      - ![image](https://user-images.githubusercontent.com/61530368/174329331-2da226c7-b5cb-4b5a-9006-495a238ae7dd.png)
    - 스트림 암호로서의 Counter(CTR)모드
      - ![image](https://user-images.githubusercontent.com/61530368/174329371-3a80aa34-c64a-4ed0-b04a-d4c6f529b370.png)
    - CTR 모드 알고리즘
      - ![image](https://user-images.githubusercontent.com/61530368/174329429-f368c9b8-968d-412d-90b7-1ad62b0a1a29.png)
    - 안전성
      - OFB 모드의 안전성과 동일
    - 오류파급
      - 암호문의 한 비트 오류는 단지 대응되는 평문의 한비트에만 영향을 미치는 것으로 분석됨 
  - 5가지 운영모드의 요약과 비교
    - ![image](https://user-images.githubusercontent.com/61530368/174329558-5be5c878-9724-4fa5-a7ba-25ab25dfab69.png)
    
## 스트림 암호의 사용
  - 개요
    - 앞에서 설명한 5가지의 운영모드는 큰 단위 (ECB, CBC, CTR)의 파일과 작은 단위 (CFB, OFB)의 데이터를 암호화하기 위하여 효과적으료 이용될 수 있음
    - 그러나 문자나 비트와 같은 작은 단위의 데이터를 암호화하기 위하여 스트림 암호가 필요
    - 스트림 암호는 real-time 프로세싱에서 좀 더 효율성을 갖는 것으로 확인되었으며, 이에 따라 몇몇 스트림 암호는 실제 다양한 프로토콜에서 사용됨 

# 메시지 인증
## 메시지 인증 개요
  - 메시지 인증이란?
    - 전송 중인 메시지 내용의 모결성을 보장하기 위한 방법
    - 즉, "메시지가 올바른 송신자로부터 온것이다."를 보장하는 방법
  - 메시지 인증
    - 메시지 암호화 방식
    - 해시함수를 이용한 방식
  - 메시지 인증 개요
    - MAC (Message Authentication Code)
      - 무결성을 확인하고, 메시지에 대한 인증을 위한 코드 
      - 초기에는 DES의 CBC 운영 모드를 이용하여 MAC 생성
      - 최근에는 해시 함수 기반의 MAC 생성 방식을 주로 사용
    - 메시지 인증 일반 모델
      - 만일 수신된 MAC과 계산된 MAC이 일치한다면,
      - 수신자는 메시지가 변경되지 않았다고 확신할 수 있음
      - 수신자는 합버적 송신자로부터 메시지가 왔다고 확신 
      - ![image](https://user-images.githubusercontent.com/61530368/173175238-8fa0ad93-9437-4aa4-b23a-a3a98deaeb65.png)
    - 메시지 인증의 필요성
      - 노출(disclosure): 제 3자에게 메시지 내용이 노출
      - 트래픽 분석(traffic analysis): 통신 주체 사이의 어떤 트래픽 형태를 발견
      - 위장(masquerade): 부정한 출처로부터의 메시지 삽입
      - 내용수정(content modification): 메시지 내용의 변경
      - 순서 수정(sequence modification): 메시지의 지연과 재전송
      - 부인(repudiation): 메시지의 송신이나 수신 부인
       
## 메시지 인증 함수
  - 인증 함수
    - 메시지 인증은 아래와 같이 2단계로 수행
      - 1단계: 인증자(authenticator) 생성
      - 2단계: 인증자 검증
    - 인증자 생성 함수의 유형
      - 메시지 암호화(전체 메시지의 암호문이 인증자로서 제공)
      - 메시지 인증 코드 (MAC)
      - 해시 함수 
  - 관용 암호 방식 이용 
    - 기밀성 제공
      - A와 B만이 K를 공유하고 암/복호화 가능
    - 단순한 인증 제공
      - K를 알고 있는 A만이 해당 암호문을 작성할 수 있음
    - 서명 제공 불가
      - 수신자가 메시지를 위조할 수 있으며, 송신자는 메시지의 송신여부를 부인할 수 있음
    - ![image](https://user-images.githubusercontent.com/61530368/173175432-ffab1735-e65a-4799-a803-50bc430c3079.png)
  - 단순 공개키 암호 방식의 이용(1)
    - 기밀성 제공
      - 메시지를 복호화할 수 있는 사용자는 B뿐임
    - 인증은 제공하지 못함
      - 누구나 B의 공개키를 이용할 수 있음 (공개키로 암호화 했기 때문에 누구인지 모름)
    - ![image](https://user-images.githubusercontent.com/61530368/173175459-b7fe3308-fb26-4dab-b463-a2969d1be17a.png)
  - 단순 공개키 암호 방식의 이용(2)
    - 인증과 디지털 서명은 제공하나 기밀성은 제공하지 않음
    - 기밀성 미 제공
      - 누구나 A의 공개키를 가질 수 있고 복호화가 가능
    - 인증과 디지털 서명 제공
      - A만이 메시지를 생성할 수 있으며, B는 암호문을 구성할 수 없음
    - ![image](https://user-images.githubusercontent.com/61530368/173175524-709cdb4e-0113-468c-812f-8944ceab9455.png)
  - 공개키 암호방식의 이중 적용
    - 인증과 디지털 서명 제공
      - KUa로 복호화 될 수 있는 암호문은 KRa의 소유자만 작성 가능
    - 기밀성 제공
      - KUb로 암호화된 메시지는 KRb 소유자만 복호화 가능    
    - ![image](https://user-images.githubusercontent.com/61530368/173175811-33221a63-47e3-4b52-9942-eba6a7a81d73.png)

## 메시지 인증 코드
  - 메시지 인증 코드
    - 암호학적 점검값이 MAC을 메시지에 추가하는 방식
    - 암호학적 점검값
      - 비밀키를 사용하여 생성된 작은 크기의 데이터 블록으로, 메시지와 키에 대한 함수
    - 송신자는 메시지와 MAC을 함께 정송하고 수신측에서는 계산한 MAC과 수신한 MAC을 비교하여 인증을 수행
      - 수신자는 메시지 변경이 없음을 확신
      - 수신자는 합법적인 송신자로부터 메시지가 왔음을 확신
      - 메시지 내에 순서번호가 있는 경우 수신자는 합법적인 순서를 확신
    - 단, 송수신자가 같은 키를 사용하므로 디지털 서명 기능은 제공 못함
  - 1. 암호학적 점검값 사용
    - 메시지 내용 인증
      - K를 모르는 공격자가 메시지와 대응되는 점검값을 구성할 수 없음
    - 출처 인증
      - K를 아는 A만이 올바론 점검값을 작성하여 전송 가능함
    - ![image](https://user-images.githubusercontent.com/61530368/173175882-99c61a6e-2b04-47ff-a4b3-b7df63f59cf0.png)
  - 2. 암호학적 점검값 사용
    - 인증제공 
      - A와 B만이 K1을 공유
    - 기밀성 제공
      - A와 B만이 K2를 공유
    - 평문 + 인증
      - 평문 즉시 사용 가능하며, 인증은 필요시 수행 
    - ![image](https://user-images.githubusercontent.com/61530368/173175928-37896be9-b577-4e60-9d7b-c06713865e01.png)
  - 3. 암호학적 점검값 사용
    - 인증 제공 
      - A와 B만이 K1을 공유 
    - 기밀성 제공
      - A와 B만이 K2를 공유 
    - 암호문 + 인증  
      - 복호화후 평문 사용 가능하며, 인증을 위해서는 암호문이 필요함 
    - ![image](https://user-images.githubusercontent.com/61530368/173176000-12720368-ecf8-473b-adb7-75ce5ffb8e83.png)
  - 해시 함수
    - 해시함수란?
      - 임의의 길에 이진 문자열을 고정된 길이의 이진 문자열(해시값, 메시지 다이제스트, 메시지 지문)로 매핑하여 주는 함수
      - ![image](https://user-images.githubusercontent.com/61530368/173176295-32ea5483-8580-488b-b519-1f8792de9fc2.png)
  - 1. 해시 함수의 사용
    - 인증 제공
      - H(M)을 관용키 암호화 방식으로 보호함
    - 기밀성 제공
      - A와 B만이 K를 공유
    - ![image](https://user-images.githubusercontent.com/61530368/173176329-fd808e30-6c77-43ad-95ad-0b5d8481bd1c.png)
  - 2. 해시 함수 사용
    - 인증 제공
      - H(M)만을 관용키 방식으로 암호학적 보호 
      - 메시지 내용 무결성 보장
      - 기밀성을 요구하지 않는 응용에서 처리 부하 경감 
    - ![image](https://user-images.githubusercontent.com/61530368/173176387-388636de-cd71-4d75-bb40-6651cad9f1df.png)
  - 3. 해시 함수 사용
    - 인증 제공
      - H(M)을 공개키 암호 방식으로 보호
    - 디지털 서명
      - A만이 Ekra[H(M)]을 생성 가능
    - ![image](https://user-images.githubusercontent.com/61530368/173176425-046e09f3-e4cb-40fa-b94d-303f61193492.png)
  - 4. 해시 함수 사용
    - 인증(디지털 서명)제공
      -  공개키 방식 사용하면, Ekra[H(M)]
    - 기밀성 제공
      - 메시지도 함께 암호화하며, A와 B만이 K를 공유
    - ![image](https://user-images.githubusercontent.com/61530368/173176466-3de23035-8ad2-461b-adf0-9345382787f2.png)
  - 5. 해시함수 + 비밀값 사용 (1)
    - S: A와 B 공통의 비밀값
    - 인증 제공
      - S와 B만이 S를 공유
    - 암호화 회피 이유
      - 암호화 소프트웨어의 속도 느리고, 하드웨어의 비용은 증대되는 문제
      - 아주 작은 데이터 블록에도 동일한 암호화 절차 필요   
    - ![image](https://user-images.githubusercontent.com/61530368/173176539-583412d2-2152-429f-a5aa-8ea3f0572b55.png)
  - 6. 해시함수 + 비밀값 사용 (2)
    - 인증 제공
       - A와 B만이 S를 공유
     - 기밀성 제공
       - A와 B만이 암/복호키 K를 공유
     - ![image](https://user-images.githubusercontent.com/61530368/173176604-12fbea27-f076-4374-af4c-d584ec6ce3cc.png)
  - 메시지 인증 코드란 ?
    - 키에 종속된 일방향성 해시함수: MAC = Ck(M)
      - M: 가변 길이 메시지
      - K: 송신자와 수신자만의 공유 비밀키
      - Ck(M): 고정 길이의 인증자
  - 메시지 인증 코드의 특징
    - 비밀키를 공유한 사람만이 메시지의 생성과 인증이 가능
    - MAC자체는 메시지 기밀성이나 서명기능을 제공하지 않음
    - 암호학적 점검 값 또는 메시지 인증 코드 (MAC)라고도 부름
  - MAC의 요구 조건
    - 공격자가 Ck(M')=Ck(M)인 M'을 구성이 계산적으로 어려워야 함
      - 직, 키를 알지 못하면서 MAC에 일치하는 새 메시지를 만들 수 없어야 함
    - Ck(M)은 일정하게 분산되어 있어야 함
      - 이때, n이 점검값 비트수 일 때 Ck(M)=Ck(M')일 확률은 2^(-2)
    - 메시지의 어떤 부분이나 특정 비트들이 특별히 취약해서는 안됨
      - 공격자가 "취약지점"에서 M의 변형을 시도 가능 
  - 생일 공격
    - 전사적 공격의 일종으로 Birthday Paradox(생일 역설)또는 생일 문제 기반
      - 같은 생일을 가진 사람이 두 사람 이상 있을 확률이 1/2보다 크려면 23명 이상이면 충분
  - Brute-Force 공격
    - 해시 함수
      - Brute-force 공격에 대한 해시 함수의 강도는 오직 알고리즘에 의해 성성되는 해시 코드의 길이에 의존
      - 해시 함수의 특성
      - 1. 일방향성: 입력을 모르는 해시값 y가 주어졌을 때, h(x') = y를 만족하는 x를 찾는 것은 계산적으로 어렵
      - 2. 약한 충돌 회피성: h(x)가 주어졌을 때 h(x') = h(x)인 x'(!=x)을 찾는 것은 계산적으로 어려움
      - 3. 강한 충돌 회피성: h(x')=h(x)인 서로 다른 임의의 두 입력 x와 x'을 찾는 것은 계산적으로 어렵
    - 메시지 인증 코드
      - MAC에 대한 전사적 공격은 알려진 메시지-MAC pair가 있어야 가능하므로 매우 어려움
      - 코드 길이가 n-비트인 경우
        - 충돌을 찾는 brute-force 방식은 무작위 비트 열 y를 선택해 H(y) = H(x)인지 확인
        - 공격이 가능한지의 여부는 MAC과 키의 상대적 크기에 따라 결정됨
      - 계산적 어려움(Computation resistance)
        - 하나 또는 그 이상의 문서-MAC pair(xi, Ck(Xi))가 제공된 경우, 새로운 입력 값 x != xi가 되는 (x, Ck(x))를 계산하는 것은 불가능 
    - 공격의 형태
      - 키 공간 공격: 키 크기가 K일 경우 2^k이상
      - MAC 값 공격: MAC의 크기가 n일 경우 2^n
    - 공격 노력(min2^k, 2^n): 따라서 min(k, n) >= 128을 만족하여야 함                     
# Hash Algorithms
## Merkel-Damgard구조
  - Merkel-Damgard 구조 
    - ![image](https://user-images.githubusercontent.com/61530368/174441565-eb730cea-f47a-4b48-aabc-f5b9b6561e60.png)
  
## MD5
  - MD5 로직
    - MD5 로직
      - 입력: 임의의 길이의 메시지
      - 처리단위: 512비트 블럭
      - 출력: 128비트 메시지 다이제스트
    - MD5의 로직은 총 5단계로 구성
      - 패딩 비트의 추가
      - 메시지 길이의 증가
      - MD버퍼의 초기화
      - 512비트(16워드) 블록의 메시지 처리
      - 출력 
    - MD5를 이용한 메시지 다이제스트(MD) 생성
      - ![image](https://user-images.githubusercontent.com/61530368/174441631-9026ea44-79a7-4e0a-ab07-a1284ee125c8.png)
    - 1단계: 패딩 비트 추가
      - 입력 메시지가 512비트의 블록들로 처리되므로 패딩을 사용하여 입력 메시지의 길이가 512로 나누어 떨어지게 함(즉, mod512 = 0)
      - 패딩된 메시지 길이 : (L *512) - 64비트
      - 패딩 비트: 1로 시작한 0들의 조합으로 패딩
      - 나머지 64비트: 데이터 길이(little endian)
      - 메시지가 원하는 길이일지라도 패딩은 항상 부가 
      - ![image](https://user-images.githubusercontent.com/61530368/174441690-9377c902-f895-4786-945a-4a61f2bf37ca.png)
    - 2단계: 메시지 길이의 증가
      - 패딩 이전 본래 메시지의 길이를 64비트로 표현하여 증가
      - 1, 2단계에 의해 길이가 512비트의 정수배가 되는 메시지를 얻음
      - 확장된 메시지의 전체 길이는 512 x L
    - 3단계: MD 버퍼의 초기화
      - 버퍼: 32비트 길이의 레지스터 4개(A,B,C,D)로 구성
      - 버퍼의 용도: 해시 함수의 중간 결과와 최종 결과를 저장
      - 레지스터들은 다음과 같은 16진수의 값으로 초기화
      - 각 버퍼에 little-endian 방식으로 저장 
    - 4단계: 512블럭(16 단어)의 메시지 처리
      - 입력
      - 512비트 블럭
      - 128비트 버퍼값(A,B,C,D)
      - 사인 함수로 구성되는 64개 요소 (T[1] ~ T[64]중 16개씩 적용) 
      - 알고리즘
      - 4개의 라운드 처리로 구성된 모듈
      - 같은 함수 구조를 가지면서 서로 다른 기약함수에 의존 
      - T[i]에서 i번째 요소는 2^32 * abs(sin(i))의 정수 부분과 일치 
    - 5단계: 출력
      - L개의 512비트 입력블록이 처리되고, L번째 단계의 128비트 메시지 다이제스트 출력 
    - MD5의 전체적인 과정 
      - ![image](https://user-images.githubusercontent.com/61530368/174441898-4825c316-89d9-4a6c-b7d3-6749db65b9bc.png)
      - ![image](https://user-images.githubusercontent.com/61530368/174441902-344648c4-4f67-49df-98c8-77f35bac6f27.png)
  - MD5 압축 함수
    - ![image](https://user-images.githubusercontent.com/61530368/174441974-cba94d0b-1dac-485a-89e3-1f2d94032c3b.png)
    - 각 라운드는 버퍼 ABCD 상에서 처리하는 16단계의 연속으로 구성
    - ![image](https://user-images.githubusercontent.com/61530368/174442002-59fe5527-72da-4599-a28e-c5fbefe84cb9.png)
    - 처리 결과
      - 32비트 단어 배열{X[0], ..., X[15]}는 현재 처리되고 있는 512비트 블럭값을 가짐
      - 한 개의 512비트 블록은 16회 반복을 통하여 X[0] 부터 X[15]까지 처리됨
      - T[i]를 순서대로 16개씩 적용함
      - 입력의 각 32비트 단어는 라운드마다 한 번씩 4번 사용되고, 사인함수의 64개의 32비트 단어 요소의 각각은 정확히 한번 사용됨 
      - 각 단계에 대하여 버퍼의 4바이트 중 하나만이 갱신됨
      - 각 단계는 워드 단위의 우측 순환 쉬프트 연산을 수행 
  - MD5의 강도
    - 해시코드는 모든 입력 비트의 함수 결과
    - 기본함수(F, G, H, I)는 잘 혼합된 결과의 효과를 유도
    - 같은 MD를 갖는 두개의 메시지 찾기: 2^64
    - 주어진 MD를 갖고 메시지 찾기: 2^128
    - 모듈러 연산방식이 XOR 방식보다 강한 것으로 인식
    - 생일 공격의 가능성 증가 
      - 안전성 향상을 위하여 보다 긴 해시 코드의 필요성 증가     
     
## Secure Hash Algorithm(SHA)
  - SHA-1 논리
    - 최대 2^64비트 미만의 길이 메시지 입력
    - 512비트의 블록 단위로 처리
    - 160비트 메시지 다이제스트 출력
    - MD5의 구조를 다르고, 유사한 처리 과정을 수행 
    - 단계1: 패딩 비트의 부가
    - 단계2: 메시지 길이의 부가
    - 단계3: MD버퍼의 초기화 (big endian 형태로 저장)
    - 단계4: 1개의 블록 처리
      - 20단계의 4라운드 처리로 구성
      - 4개의 각 라운드는 f1, f2, f3, f4로 표현되는 4가지의 기약 논리함수 사용
      - 80개의 덧셈 상수 사용
      - 마지막 단계의 출력에 CVq를 더하여 CVq+1을 생성 
    - 단계5: 출력
      - ![image](https://user-images.githubusercontent.com/61530368/174442267-80d450aa-52ea-4c1b-a9a5-1dc24f197b6f.png)
    - ![image](https://user-images.githubusercontent.com/61530368/174442194-6f52a338-3535-4fbe-925f-e67d5da39501.png)
  - SHA-1 압축함수
    - ![image](https://user-images.githubusercontent.com/61530368/174442279-479192f4-efc4-4e08-a3e5-7f0ef2791641.png)
## RIPEMD-160
  - RIPEMD-160 기본 구조
    - 단계1: 패딩 비트 추가
      - 메시지는 비트의 길이가 512로 나누어 떨어지도록 패딩 비트를 추가함 
      - 패딩은 항상 부가하며 패딩 비트 수는 1~512비트 
    - 단계2: 메시지 길이 추가
      - 원래 메시지의 길이 계산
      - 64비트 블록에 길이 정보 부가, 부호 없는 정수형
      - Little-Endian 규칙을 따름 
    - 단계3: MD 버퍼의 초기화
      - 160비트 버퍼는 해시의 중간 결과와 최종 결과 저장
      - 5개의 32비트 레지스터(A,B,C,D,E)
      - 각 레지스터들은 고정된 값으로 초기화
      - SHA-1에서 사용된 값과 동일 ,Little-Endian 형태로 저장 
    - 단계4: 512비트 블록 메시지 처리
      - 16단계로 되어 있는 10라운드의 처리
      - 10라운드는 두개의 5라운드로 나뉘어 병행처리
      - 각 라운드는 각각의 f1,f2,f3,f4,f5 기약 논리함수 사용
      - 각 라운드는 서로 다른 9가지(0의 값 포함)의 덧셈상수(Kj)사용
      - 좌, 우 5번째 라운드에서 CVq+1을 생성하기 위해 모듈러 2^32 덧셈 수행 
    - 단계5: 출력
      - 160비트 메시지 다이제스트 생성
    - ![image](https://user-images.githubusercontent.com/61530368/174442600-18515e67-ff01-4577-abd7-159cc76beb4f.png)
  - RIPEMD-160 논리
    - ![image](https://user-images.githubusercontent.com/61530368/174442619-ee64ef5d-fcf6-449d-8e1d-b624f3db9f00.png)
  - RIPEMD-160, MD5, SHA-1과의 비교 
    - ![image](https://user-images.githubusercontent.com/61530368/174442650-39ec549b-105f-4f97-836e-53e675e8b5b0.png)
   
## HMAC(Hashed-MAC)
  - HMAC
    - FIPS PUB 113: 대칭 블록 암호에 기반한 MAC 계산(데이터 인증)
    - 암호 해시 코드를 이용한 MAC 사용 증가 이유
      - 암호 해시 함수가 대칭 블록 암호보다 빠름
      - 암호 해시 함수에 대한 라이브러리 코드의 입수 용이
      - 암호 해시 함수에 대한 수출 제한 없음 
    - MD5와 같은 해시 함수는 비밀키에 의존하지 않음 
    - 비밀키를 기존의 해시 알고리즘에 결합 
  - HMAC 설계 목표
    - RFC 2104의 HMAC 설계 목표
      - 기존의 해시 함수를 변경 없이 사용 가능해야함
      - 해시 함수는 소프트웨어적으로 구현 가능, 무상입수 용이
      - 내장 해시 함수 교체 용이
      - 성능 저하 없이 해시 함수의 원래 성능 계속 유지
      - 간단한 방법으로 키 조작 
      - 인증 메커니즘의 암호학적 분석 이해 가능
  - HMAC 알고리즘
    - ![image](https://user-images.githubusercontent.com/61530368/174442816-f8ef6105-4fae-4637-99ce-63e296f868a0.png)
    - ![image](https://user-images.githubusercontent.com/61530368/174442805-45e1b6f2-618f-47eb-ab86-3578a19660ce.png)
    - b비트 스트링 K+ 생성
      - 비밀키 K의 왼쪽에 0을 첨가
    - b비트 블록 Si를 생성
      - K+와 ipad를 XOR
    - M을 Si에 추가
      - Msg1 = [Si||M]; 대상 메시지에 Si를 붙여서 해시 처리에 입력
    - "단계 3"의 Msg에 해시를 적용
      - n비트 다이제스트를 갖는 해시알고리즘 사용 
    - b비트 블록 S0를 생성
      - K+와 opad를 XOR
    - 단계 4에서 만들어진 해시함수 적용결과에 S0를 추가
      - Msg2 = [S0 || H(Msg1)]


# 디지털 서명 
## 디지털 서명의 개요
  - 디지털 서명이란?
    - 메시지의 송신자가 Alice라는 확실성을 증명해줄 수 있는 수단
    - ![image](https://user-images.githubusercontent.com/61530368/174443198-aa63e1d7-704c-4e4b-bf47-39e7d978ecaa.png)
  - 디지털 서명에서 키의 필요성
    - 자신이 갖고 있는 개인키를 이용하여 문서에 서명 -> 서명 알고리즘 사용
    - 검증하는 사람은 서명자가 배포한 공개 키를 이용하여 문서를 검증 -> 검증
    - 따라서 디지털 서명에는 공개키 시스템 사용 
  - 다이제스트에 서명하기
    - 메시지 다이제스트는 메시지와 일-대-일 대응 관계가 성립
      - 메시지 다이제스트 = 메시지에 대한 fingerprint 역할을 수행
    - 따라서, 송신자는 메시지 다이제스트에 서명하고 수진자는 메시지 다이제스트를 검증하는 절차로 구현 가능
    - ![image](https://user-images.githubusercontent.com/61530368/174443363-92cead83-1dba-4a61-bf57-ba425df34573.png)
  - 디지털 서명의 서비스
    - 메시지 인증
      - 디지털 서명은 메시지 인증을 보장함
    - 메시지 무결성
      - 메시지가 변경되면 서명이 달라짐 -> 무결성 보장
    - 부인 봉쇄와 기밀성 
  - 디지털 서명의 서비스 - 부인 봉쇄   
    - 신뢰받는 제 3자(center)를 이용하여 부인 봉쇄를 구현
    - Alice는 자신의 메시지로부터 서명을 생성, 메시지와 ID, Bob의 ID, 서명을 센터로 전송
    - 센터에서는 Alice의 공개 키가 확실하다는 것을 확인, 그 메시지가 Alice로부터 왔다는 것을 Alice의 공개키로 검증 
    - 센터는 메시지의 복사본과 Alice의 ID, 수신자의 ID 및 타임스탬프를 저장
    - 센터는 자신의 개인키를 이용해서 메시지로부터 또 다른 서명을 생성하고 그 메시지와 새로운 서명, Alice의 ID, Bob의 ID를 Bob에게 전송
    - Bob은 신뢰하는 센터의 공개 키를 이용해서 메시지를 검증 
    - ![image](https://user-images.githubusercontent.com/61530368/174443457-4c5a4739-f0a0-45f3-bc8a-fd573ce17d94.png)
  - 디지털 서명의 서비스 -기밀성
    - 디지털 서명은 메시지에 대한 기밀성을 보장하지 않음
    - 기밀성이 요구되는 경우 비밀 키 또는 공개키를 이용해서 암호화를 해야함 
    - ![image](https://user-images.githubusercontent.com/61530368/174443550-fae0f090-c7fd-42a7-abb1-0c85e700a5db.png)

## RSA 디지털 서명구조
  - 개요
    - RSA암호시스템의 개념을 이용하여 메시지를 서명/검증하는 방법
    - 송신자는 자신의 개인키를 이용해서 메시지에 서명
    - 수신자는 송신자의 공개 키로 해당 서명을 검증
    - 검증 알고리즘에서는 메시ㅣㅈ와 함수의 출력이 합동인지 아닌지 비교
    - ![image](https://user-images.githubusercontent.com/61530368/174443578-89b053f5-5549-40be-a7c3-93ade8cc2f18.png)
  - 키생성
    - RSA 암호시스템에서 키 생성 방법 과 동일 
      - Alice는 두 소수 p와 q를 선택한 후 n = pXq를 계산
      - 오일러(n) = (p-1)(q-1)를 계산
      - 공개키로 e를 선택, eXd = 1 mod 오일러(n)을 만족하는 값 d를 계산하여 이를 개인키로 사용
      - d를 개인 키로 취하고 n과 e는 공개 
  - 서명
    - Alice는 자신의 개인 키 d를 사용하여 아래와 같이 메시지 M에 서명 
      - ![image](https://user-images.githubusercontent.com/61530368/174443661-6453cf82-efb0-4fae-9fe1-e2ee99ff7b55.png)
    - 메시지 M과 서명 S를 Bob에게 전송 
    - ![image](https://user-images.githubusercontent.com/61530368/174443677-37177eb3-b83a-4bff-876e-cf0628caa052.png)
  - 검증
    - Bob은 메시지 M과 서명 S를 수신, 서명에 Alice의 공개 키 e를 사용하여 서명 S를 검증. 이를  위해, 우선 M' = S^e mod n을 계산
    - Alice로부터 수신한 메시지 M과 Bob이 계산한 결과 M'을 비교하여 두 값이 합동이면 메시지 M을 받아드림 
  - 메시지 다이제스트에 대한 RSA 서명
    - RSA 디지털 서명 구조의 단점
      - 개인 키로 암호화하고 공개 키로 복호화하는 것이므로 속도가 느린 담점이 있음
      - 이 때, 메시지 대신에 메시지 다이제스트에 서명하면 서며오가 검증 절차를 훨씬 빠르게 수행 가능    
## ElGamal 디지털 서명 구조
  - 개요
    - ElGamal 디지털 서명 구조에서 두 개의 함수는 두 개의 서명을 생성
    - 서명 과정: 두 개의 함수가 두 개의 서명을 생성
    - 검증 과정: 두 함수에서 출력된 값을 비교하여 확인 
    - ![image](https://user-images.githubusercontent.com/61530368/174443992-fc0a3888-03d7-4767-b215-ec5c7767354d.png)
  - 키생성 
    - ElGamal 암호화 시스템에서 키를 생성하는 방법과 동일
      - p: Z^*p 안에서 이산 대수를 풀 수 없을 정도로 충분히 큰 소수
      - e1: Z^*p 안의 원시 근
      - Alice는 개인 키 d가 p-1보다 작은 수가 되도록 선택하고, d를 이용하여 공개 키로 사용할 값 e2 = e1^d를 계산
      - Alice의 공개 키는 (e1, e2, p)이고 개인 키는 d이다 
  - 서명
    - Alice는 비밀 난수 r을 선택(이 때, 새로운 메시지에 서명할 때 마다 r을 새로 생성)
    - 첫 번째 서명 S1 = e1^r mod p와 두 번째 서명 S2= (M-dXS1)Xr^-1 mod(p-1)을 계산. 여기서 r^-1은 r의 "mod p"에서 수행되는 곱셈 연산에 대한 역원임
    - M과 S1, S2를 Bob에게 전송  
    - ![image](https://user-images.githubusercontent.com/61530368/174444149-5f31c00b-650d-4422-a51b-ba72859e6401.png)
  - 검증
    - Bob은 S1과 S2가 각각 0 < S1 < p과 0 < s2 < p-1를 만족하는지 확인함
    - 그 다음, V1 = e1^M mod p 와 V2 = e2^S1 X S1^S2 mod p를 계산
    - V1과 v2가 합동이면 메시지를 받아드림    
## Schnorr 디지털 서명 구조
  - 개요
    - ElGamal 디지털 서명의 문제점
      - Z^*p상의 이산 대수 문제로부터 안전해지기 위해서 p가 매우 큰 소수가 되어야한다는 점
      - 이에 따라, ElGamal의 전체적인 구조는 유지하되, 서명의 길이는 줄이는 위한 방법이 고안 ->  Schnorr 디지털 서명구조 
  - 서명 과정
    - 두 개의 함수는 두개의 서명을 생성
  - 검증 과정
    - 하나의 함수에서 출력된 것을 첫 번째 서명과 비교하여 검증
    - ![image](https://user-images.githubusercontent.com/61530368/174444260-f106b9a3-9c15-4a5f-81fa-ccb1947fe3f6.png)
  - 키생성 
    - Alice는 길이가 1024비트가 되는 소수 p를 선택
    - 암호학적 해시 함수로 생성되는 다이제스트와 같은 길이의 소수 q를 선택 이때 소수 q는 p-1의 약수
    - e1을 모듈로 p의 번째 근으로 선택, 이를 위해 Alice는 Zp에 속하는 원시근 e0를 구하고, e1=e0^(p-1)/q mod p를 구함
    - 하나의 정수 d를 구해서 자신의 개인키로 사용, e2= e1^d mod p를 계산
    - 결과적으로 Alice의 공개 키는 (e1, e2, p, q)이고 개인 키는 d이다 
  - 서명
    - Alice는 임의의 수 r(1<r<q)을 선택(r은 새로운 메시지를 서명할 때마다 새로운 값으로 선택)
    - 첫 번째 서명 S1 = h(M|e1^r mod p)를 계산. 이 때, 메시지는 e1^r mod p 의 앞 부분에 붙인 다음 다이제스트를 생성하기 위해 해시 함수를 적용
    - 단, 해시 함수는 메시지에 직접 적용하지 않고 M을 e1^r mod p의 앞부분에 붙인 다음에 적용
    - 그 다음, 두 번째 서명 S2 = r + d X S1 mod q를 계산
    - Alice는 M과 S1, S2를 Bob에게 전송 
    - ![image](https://user-images.githubusercontent.com/61530368/174444403-517630b3-ca95-4016-8423-b543e3d8d3ec.png)
  - 검증
    - Bob은 ![image](https://user-images.githubusercontent.com/61530368/174444458-17768564-94c6-4bda-90dc-1efb834ddb11.png) 를 계산
    - 만약 S1이 모듈로 P로 V와 합동이면 메시지를 받아드림 
  
## 디지털 서명 표준(DSS)
  - 디지털 서명 표준이란?
    - Schnorr 구주에서 빌려온 개념을 ElGamal 구조를 기반으로 한 디지털 서명알고리즘 사용 
    - ![image](https://user-images.githubusercontent.com/61530368/174445850-c372e7db-2a8f-4749-9cd5-4477b20bf14e.png)
  - 키생성
    - Alice는 길이가 512비트에서 1024비트 사이인 소수 p를 선정. 이때, p의 비트 수는 64의 배수가 되어야 함
    - Alice는 160비트 소수 q를 선택. 이 때, q가 p-1의 약수가 되어야 함
    - 그 다음에, Alice는 키 생성을 위해 두 개의 곱셈 군 <Z^*p,X>와 <Z^*q,X>를 사용해야함. 여기서 두 번째 곱셈 군 <Z^*p,X>은 첫 번째 곱셈 군<Z^*p,X>의 부분군임
    - Alice는 e1^q = 1 mod p를 만족하는 e1을 구함. 이를 위해, Zp의 한 원시 근인 e0를 구하고 이후 관계식 e1 = e0^(p-1)/q mod p를 사용
    - Alice는 d값을 하나 취해서 개인 키로 사용, 이를 이용하여 e2 = e1^d mod p를 계산
    - 결과적으로 Alice의 공개키는 (e1,e2,p,q)이고 개인 키는 d임 
  
  - 서명 
    - Alice는 임의의 수 r(1<= r<= q)를 선택. 이 때, 새로운 메시지에 서명할 때마다 새로운 r을 계산
    - Alice는 첫 번째 서명 S1 = (e1^r mod p ) mod q를 계산 
    - 이후, 메시지 다이제스트 h(M)을 생성하고 두 번째 서명 S2 = (h(M) + dS1)r^-1 mod q를 계산
    - 마지막으로, Alice는 M과 S1, S2를 Bob에게 전송 
    - ![image](https://user-images.githubusercontent.com/61530368/174446211-30e1fa61-4404-4f54-a79b-342029b3ee9b.png) 
  - 검증 
    - Bob은 ![image](https://user-images.githubusercontent.com/61530368/174446221-1aee133c-3229-4e59-9db4-1d9d423b79ff.png) 를 계산
    - 만약 S1이 V와 합동으로 같으면 메시지를 받아들임 
  - RSA, ElGamal 서명과의 비교 
    - RSA 서명과의 비교
      - 동일한 소수 p를 사용할 경우 DSS 서명 계산이 RSA 알고리즘 계산보다 빠름
    - ElGamal 서명과의 비교
      - DSS 서명에서 사용하는 소수 q가 p보다 작기 때문에 ElGamal 서명보다 길이가 짧음      

# 키 관리의 기본 개념
## 키의 특성과 종류
  - 키의 특성
    - 암호를 사용하기 위해서는 키라 불리는 매우 큰 수가 필요
      - 키 공간의 크기가 클 수록 제 3자의 공격으로부터 안전
      - 이 때, 키 공간의 크기는 키의 비트 길이로 결정됨
    - 정보의 기밀성의 핵심 원리 
      - * 정보의 기밀성은 암호 알고리즘을 비밀로 하는 것이 아니라 키를 비밀로 하는 것에 의해 지켜져야함 (매우중요)
  - 보안 속성에 따른 키의 분류
    - 기밀성을 유지하기 위한 키
      - 대칭 암호 및 공개 키 암호 시스템에서 사용하는 키
      - 복호화 키를 모르면 암호문을 해독할 수 없음
    - 인증을 수행하기 위한 키
      - 메시지 인증 코드 및 디지털 서명에서 사용하는 키
      - 키를 모르면 데이터 변경이나 위장이 불가 
  - 대칭 키
    - 암호화, 복호화에서 사용되는 키가 동일한 경우 
  - 비대칭 키(공개 키)
    - 암호화, 복호화에서 사용되는 키가 서로 다른 경우
      - 암호화 -> 공개 키 사용
      - 복호화 -> 개인 키 사용 
  - 메시지 인증 코드 키 (메시지의 무결성에 초점)
    - 송신자와 수신자가 공통의 키를 사용해서 인증을 수행 
    - ![image](https://user-images.githubusercontent.com/61530368/174446453-ac5a338a-4ec2-4690-ae0f-8b1208fc2c8a.png)
  - 디지털 서명 키
    - 서명 작성과 서명 검증에 서로 다른 키를 사용(메시지를 누가 보냈는지에 대한 검증)
    - ![image](https://user-images.githubusercontent.com/61530368/174446485-e32ef667-0f30-477a-853a-ea532da3815a.png)
## 키 관리 
  - 키 생성
    - 난수를 이용한 키 생성
      - 난수는 사전에 추측하기 어려우므로 키로 사용하기 적합
      - 암호용으로 설계된 의사 난수 생성기 소프트웨어를 사용하여 키 생성
    - 패스워드를 이용한 키 생성
      - 패스워드를 일방향 해시 함수에 입력해서 얻어진 해시 값을 키로 이용
      - 패스워드에 "솔트(salt)"라 불리는 난수를 부가해서 일방향 해시 함수에 입력하고 그 출력을 키로 사용 
        - 패스워드를 기초로 한 암호(password-based encryption:PBE)
  - 키 배송
    - 키를 수신자에게 전달하는 방법
      - 키를 사전에 공유하는 방법
      - 키 배포 센터를 이용하는 방법
      - 공개 키 암호를 사용하는 방법
      - Diffie-Hellman 키 교환 알고리즘 
  - 키 갱신
    - 키 갱신(key updating)
      - 공통 키를 사용하여 통신을 하고 있는 도중에 정기적으로 키를 교환하는 방법
      - 현재 키의 해시 값을 다음 키로 사용
    - 키 갱신의 장점
      - 키 노출 시 과거 통신 내용의 복호화를 막을 수 있음 
  - 키 보존
    - KEK(Key Encryptiong Key)
      - 키를 암호화하는 키
      - 다수의 키를 한개의 키(KEK)로 암호화 하여 보관하는 방법  
      - ![image](https://user-images.githubusercontent.com/61530368/174446651-b087a174-a2c7-40c5-aada-e90709961e57.png)
## Diffie-Hellman 키 교환
  - Diffie-Hellman 키 교환 알고리즘
    - 타인에게 알려져도 상관없는 정보를 두 사람이 교환하는 것만으로 공통의 비밀 값을 만들어내는 방법 
  - Diffie-Hellman 키 교환 알고리즘의 기본 수행 절차
    - Alice는 Bob에게 2개의 소수 P와 한 원시근 G를 송신
    - Alice는 난수 A를 준비
    - Bob은 난수 B를 준비
    - Alice는 Bob에게 G^A mod P를 송신
    - Bob은 Alice에게 G^B mod P를 송신
    - Alice는 Bob이 전송한 수에 A를 제곱한 후 모듈러 P를 계산
      - Alice가 계산한 키 = (G^B mod P)^A mod P = G^(BXA) mod P
    - Bob은 Alice가 전송한 수에 B를 제곱한 후 모듈러 P를 계산
      - Bob이 계산한 키 = (G^A mod P)^B mod P = G^(AXB) mod P  
    - Alice가 계산한 키 = Bob이 계산한 키 
    - ![image](https://user-images.githubusercontent.com/61530368/174446826-8de704b8-9071-47f7-9256-ef1472d57d32.png)
  - Diffie-Hellman 키 교환 알고리즘의 특징
    - 공격자 Eve가 알 수 있는 것
      - P, G, G^A mod P, G^B mod P
    - 위 4개의 수로부터 Alice와 Bob이 공유한 키 (G^AXB mod P)를 계산하는 것은 수학적으로 난해함
      - 즉, 이는 전형적인 유한 체(finite field)상의 이산대수 문제임
      - 실제로, G^A mod P로 부터 수 A를 효율적으로 계산하는 알고리즘은 아직 없음 
    - 따라서 유한 체 상의 이산대수 문제를 풀기 어렵기 때문에 Diffie-Hellman키 교환의 안전성이 보장됨        
  - 키 교환 예제
    - Alice는 Bob에게 두 개의 수 P=13과 G=2를 송신
    - Alice는 임의의 수 A=9를 준비
    - Bob은 임의의 수 B=7을 준비
    - Alice는 Bob에게 G^A mod P = 2^9 mod 13 =5를 송신
    - Bob은 Alice에게 G^B mod P = 2^7 mod 13 =11를 송신 
    - Alice는 Bob이 전송한 수 11을 A로 제곱한 후 모듈러 P연산을 수행 
      - ![image](https://user-images.githubusercontent.com/61530368/174447038-bb80593b-3862-424a-8242-0dd41630c439.png)
    - Bob은 Alice가 전송한 수 5를 B로 제곱한 후 모듈러 P연산을 수행  
      - ![image](https://user-images.githubusercontent.com/61530368/174447057-491ed66b-e5be-440e-af41-8916ab64c37b.png)
    - ![image](https://user-images.githubusercontent.com/61530368/174447064-3632fb75-de57-425c-9dbe-9114b6b93c92.png)

  


