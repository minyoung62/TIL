# 객체지향 언어 1
  ## 1. 객체지향 언어
  ### 1.1 객체지향언어의 역사
  ### 1.2 객체지향언어
  - 특징
    - 코드의 재사용성이 높음
    - 코드의 관리가 용이
    - 신뢰성이 높은 프로그래밍을 가능
  ## 2. 클래스와 객체
  ### 2.1 클래스와 객체의 정의와 용도
  - 클래스의 정의
    - 클래스란 객체를 정의해 놓은 것이다
  - 클래스의 용도
    - 클래스는 객체를 생성하는데 사용된다
  - 객체의 정의
    - 실제로 존재하는 것. 사물 또는 개념
  - 객체의 용도
    - 객체가 가지고 있는 기능과 속성에 따라 다름
  - 유형의 객체
    - 책상, 의자, 자동차, TV와 같은 사물
  - 무형의 객체
    - 수학공식, 프로그램 에러와 같은 논리나 개념
 ### 2.2 객체와 인스턴스
  - 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 함
 ### 2.3 객체의 구성요소 - 속성과 기능
  - 속성 : 멤버변수, 특성, 필드, 상태
  - 기능 : 메서드, 행위, 함수
 ### 2.4 인스턴스의 생성과 사용
  - p 123참고
 ### 2.5 클래스의 또 다른 정의
  - 변수 : 하나의 데이터를 저장할 수 있는 공간
  - 배열 : 같은 종류의 여러 데이터를 하나의 집한으로 저장할 수 있는 공간
  - 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
  - 클래스 : 데이터와 함수의 결합
## 3. 변수와 메서드
 ### 3.1 선언위치에 따른 변수의 종류
  - 클래스 영억 
    - 인스턴스 변수 : 인스턴스가 생성될 때 생성됨
    - 클래스변수(static 변수, 공유변수) : 클래스가 메모리에 올라갈 때 생성됨
  - 메서드영역
    - 지역변수 :변수 선언문이 수행되었을때 생성됨
### 3.2 클래스변수와 인스턴스변수
   - 인스턴스변수 
    -인스턴스가 생성될 때 마다 생성되므로 인스턴스마다 각기 다른 값을 유지
   - 클래스 변수
    - 모든 인스턴스가 하나의 저장곤간을 공유, 항상 공통된 값을 가짐
### 3.3 메서드
  - 하나의 메서드는 한 가지 기능만 수행하도록 작성하는 것이 좋다
  - 반복적으로 수행되어야 하는 여러 문장을 하나의 메서드로 정의해 놓으면 좋다
  - 관련된 여러 문장을 하나의 메서드로 만들어 놓는 것이 좋다
### 3.4 return문
### 3.5 메서드의 호출 
### 3.6 JVM의 메모리구조
  - 메서드영역(metohd area)
    - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어 분석
    - 클래스에 대한 정보(클래스 데이터)를 메서드 영역에 저장. 이 때, 그 클래스의 클래스변수도 이 영역에 함께 생성  
  - 힙(heap)
    - 인스턴스가 생성되는 공간, 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성
    - 즉, 인스턴스 변수들이 생성되는 공간
  - 호출스택(call stack 또는 execution stack) 
    - 메서드의 작업에 필요한 메모리 공간을 제공
    - 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당
    - 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
    - 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐
### 3.7 기본형 매개변수와 참조형 매개변수
  - 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다
  - 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다
### 3.8 재귀호출(recursive call)
### 3.9 클래스메서드(static메서드)와 인스턴스 메서드
  - 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙임
  - 클래스변수(static메서드)는 인스턴스를 생성하지 않아도 사용할 수 있다
  - 클래스변수(static변수)는 인스턴스변수를 사용할 수 없다
  - 메서드 내에서 인스턴스변수를 사용하지 않는다면, static을 붙이는 것을 고려한다
    - 메서드 호출시간이 짧아지기 때문에 효율이 높아진다 
    - static을 안 붙인 메서드(인스턴스메서드)는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요 
    - 때문에 인스턴스메서드는 호출 시간이 더 오래걸림  
### 3.10 클래스멤버와 인스턴스멤버간의 참조와 호출
  - static메서드에서는 인스턴스 메서드 호출 불가
  - static메서드에서는 인스턴스 변수 사용 불가
  - 클래스변수는 인스턴스 변수를 사용할 수 없음
## 4 메서드 오버로딩
### 4.1 메서드 오버로딩이란?
  - 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
### 4.2 오버로딩의 조건
  - 메서드 이름이 같아야 한다
  - 매개변수의 개수 또는 타입이 달라야 한다
  - 매개변수는 같고 린턴타입이 다른 경우는 오버로딩이 성립되지 않는다
### 4.3 오버로딩의 예
### 4.4 오버로딩의 장점

## 5 생성자(Constructor)
### 5.1 생성자란?
  - 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
  - 생성자의 이름은 클래스의 이름과 같아야 한다
  - 생성자는 리턴 값이 없다
### 5.2  기본 생성자(default constructor)
  - 생성자 메서드가 하나도 없으면 컴파일러가 자동적으로 기본생성자를 추가해준다
  - 생성자가 있을 때 기본생성자는 생성되지 않는다
### 5.3 매개변수가 있는 생성자
### 5.4 생성자에서 다른 생성자 호출하기 - this(), this
  - 생성자 간에도 서로 호출이 가능 ( 아래의 조건 만족시 가능 )
    - 생성자의 이름으로 클래스이름 대신 this를 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능
  - this
    - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다
    - 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재
  - this(), this(매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 
### 5.5 생성자를 이용한 인스턴스의 복사
  ``` java
  Car(Car c) {
    color = c.color;
    gearType = c.gearType;
    door = c.door;
  }
  ```
## 6 변수의 초기화
### 6.1 변수의 초기화
  - 지역변수 초기화
    - 사용하기 전에 반드시 초기화 필요
  - 멤버변수 초기화
    - 명시적 초기화
    - 생성자
    - 초기화 블럭
      - 인스턴스 초기화 블럭 : 인스턴스변수를 초기화 하는데 사용
      - 클래스 초기화 블럭 : 클래스변수를 초기화 하는데 사용
### 6.2 명시적 초기화(explicit initialization)
  ``` java
  class Car {
    int door = 4;            // 기본형 변수의 초기화
    Engine e = new Engine(); // 참조형 변수의 초기화
  }
  ```

### 6.3 초기화 블럭(initialization block)
  - 클래스 초기화 블럭 : 클래스변수의 복잡한 초기화에 사용
    - 클래스 초기화 블럭은 크래릇가 메모리에 처음 로딩될 때 한번만 수행
  - 인스턴스 초기화 블럭 : 인스턴스변수의 복잡한 초기화에 사용
    - 인스턴스 초기화 블럭은 생성자와 같이 인스턴스를 생성할 때 마다 수행
  - ex
   ``` java
   class InitBlock {
    static { /* 클래스 초기화블럭 입니다 */}
    {/* 인스턴스 초기화블럭 입니다 */}
   }
   ```
 ### 6.4 멤버변수의 초기화 시기와 순서
  - 클래스변수의 초기화 시점
    - 클래스가 처음 로딩될 때 단 한번 초기화
  - 인스턴스변수의 초기화 시점
    - 인스턴스가 생성딜 때마다 각 인스턴스별로 초기화가 이루어짐
  - 클래스변수의 초기화순서
    - 기본값 -> 명시적초기화 -> 클래스 초기화 블럭
  - 인스턴스변수의 초기화순서
    - 기본값 -> 명시적초기화 -> 인스턴스초기화 블럭 -> 생성자
# 객체지향 프로그래밍 2
  ## 1 상속(inheritance)
  ### 1.1 상속의 정의와 장점
  - 상속이란?
    - 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
  - 장점
    - 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생상성과 유지보수에 크게 기여
  - 조상 클래스 : 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스
  - 자손 클래스 : 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스
  ### 1.2 클래스간의 관계 - 포함관계
  ``` java
  class Circle {
    Point c = new Point(); // 원점
    int r;
  }
  ```
  ### 1.3 클래스간의 관계 결정하기
  - '~은 ~이다(is-a)'와 '~은 ~을 가지고 있다(has-a)'를 넣어서 문장을 만들어 보면 클래스 간의 관계가 보다 명확해짐
  - ex) 2번째가 더 옳다는 것을 알 수 있음 
  ```
  1. 원(Circle)은 점(Point)이다 - Circle is a Point
  2. 원(Circle)은 점(Point)을 가지고 있다 - Circle has a Point
  ```
  - 상속관계 : is-a
  - 포함관계 : has-a
 ### 1.4 단일상속(single inheritance)
  - 자바는 단일 상속만 지원
  - 이유: 만약 다중 상속일 때 부모들이 같은 메서드를 가지고 있을 때 구별하기가 힘들다 때문에 자바는 단일 상속을 선택 (다중 상속을 지원하는 언어도 있음)
 ### 1.5 Object 클래스 - 모든 클래스의 조상
  - Object 클래스는 모든 클래스 상속계층도의 제일 위에 위치하는 조상 클래스
  - 모든 클래스들은 자동적으로 Object클래스로부터 상속을받게 함
  - toString(), equals(Object o)와 같은 메서드를 따로 정의하지 않고 사용할 수 있는 이유임
 ### 2 오버라이딩(overriding)
 ### 2.1 오버라이딩이란?
  - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 함
 ### 2.2 오버라이딩의 조건
  - 이름이 같아야 함
  - 매개변수가 같아야 함
  - 리턴타입이 같아야 함
  - 하지만, 접근 제어자 + 예외는 제한된 조건 하에서만 다르게 변경 가능
  - + 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가능 
  - + 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
 ### 2.3 오버로딩 VS 오버라이딩
 
  
  
